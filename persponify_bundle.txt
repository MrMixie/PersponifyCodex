Persponify Bundle (AUTO)
projectKey: default
source: http://127.0.0.1:3020/context/latest?projectKey=default
treeCount: 34  scriptCount: 14

=== META ===
buildId: BUILD-2025-12-22-MAIN-FULL-1
builtAt: 1766419108
exporter: plugin-context-exporter
maxScriptChars: 80000
maxScripts: 250
maxTotalChars: 200000
maxTreeNodes: 2000
reason: scheduled
rulesVersion: 2025.12.22
scriptCount: 14
scriptSourceOmittedCount: 0
totalCapHit: False
totalSourceChars: 113852
treeCount: 34

=== TREE (PATHS) ===
- game/ReplicatedStorage  [ReplicatedStorage] (children=1)
- game/ReplicatedStorage/PersponifyStudioAI  [Folder] (children=6)
- game/ReplicatedStorage/PersponifyStudioAI/Assets  [Folder] (children=0)
- game/ReplicatedStorage/PersponifyStudioAI/Core  [Folder] (children=8)
- game/ReplicatedStorage/PersponifyStudioAI/Core/Config  [ModuleScript] (children=0)
- game/ReplicatedStorage/PersponifyStudioAI/Core/Connection  [ModuleScript] (children=0)
- game/ReplicatedStorage/PersponifyStudioAI/Core/ContextExporter  [ModuleScript] (children=0)
- game/ReplicatedStorage/PersponifyStudioAI/Core/DebugLog  [ModuleScript] (children=0)
- game/ReplicatedStorage/PersponifyStudioAI/Core/Executor  [ModuleScript] (children=0)
- game/ReplicatedStorage/PersponifyStudioAI/Core/Path  [ModuleScript] (children=0)
- game/ReplicatedStorage/PersponifyStudioAI/Core/Transport  [ModuleScript] (children=0)
- game/ReplicatedStorage/PersponifyStudioAI/Core/Version  [ModuleScript] (children=0)
- game/ReplicatedStorage/PersponifyStudioAI/Main  [Script] (children=0)
- game/ReplicatedStorage/PersponifyStudioAI/Protocol  [Folder] (children=2)
- game/ReplicatedStorage/PersponifyStudioAI/Protocol/Receipt  [ModuleScript] (children=0)
- game/ReplicatedStorage/PersponifyStudioAI/Protocol/Transaction  [ModuleScript] (children=0)
- game/ReplicatedStorage/PersponifyStudioAI/UI  [Folder] (children=1)
- game/ReplicatedStorage/PersponifyStudioAI/UI/Widget  [ModuleScript] (children=0)
- game/ReplicatedStorage/PersponifyStudioAI/Validation  [Folder] (children=1)
- game/ReplicatedStorage/PersponifyStudioAI/Validation/FastChecks  [ModuleScript] (children=0)
- game/ServerScriptService  [ServerScriptService] (children=0)
- game/StarterGui  [StarterGui] (children=0)
- game/StarterPlayer  [StarterPlayer] (children=2)
- game/StarterPlayer/StarterCharacterScripts  [StarterCharacterScripts] (children=0)
- game/StarterPlayer/StarterPlayerScripts  [StarterPlayerScripts] (children=0)
- game/Workspace  [Workspace] (children=5)
- game/Workspace/AITest  [Folder] (children=1)
- game/Workspace/AITest/HelloModule  [ModuleScript] (children=0)
- game/Workspace/Baseplate  [Part] (children=1)
- game/Workspace/Baseplate/Texture  [Texture] (children=0)
- game/Workspace/Camera  [Camera] (children=0)
- game/Workspace/SpawnLocation  [SpawnLocation] (children=1)
- game/Workspace/SpawnLocation/Decal  [Decal] (children=0)
- game/Workspace/Terrain  [Terrain] (children=0)

=== SCRIPTS (FULL SOURCE WHEN AVAILABLE) ===

==========================================================================================
FILE: game/ReplicatedStorage/PersponifyStudioAI/Core/Config
CLASS: ModuleScript
BYTES: 5759
SHA1: len=5759|a=38806|b=9709
------------------------------------------------------------------------------------------
-- Core/Config.lua
-- Persponify Studio AI — Config (v1 compatible, vNext-ready)
-- Goal: Keep every upgrade non-breaking + future-proof + rate-limit safe.

local Config = {}

-- =========================================
-- Identity / Tagging
-- =========================================
Config.ProductName = "Persponify Studio AI"

-- IMPORTANT:
-- Roblox blocks setting the "User-Agent" header.
-- Use this ONLY as an identifier string inside JSON bodies (clientTag), NOT headers.
Config.ClientTag = "PersponifyStudioAI/0.1.0"

-- Optional: bump when you make a breaking protocol change
Config.ProtocolVersion = 1

-- =========================================
-- Connectivity (Local Companion Server)
-- =========================================
-- Order matters: try the most reliable first.
Config.DefaultBaseUrls = {
	"http://127.0.0.1:3020",
	"http://localhost:3020",
}

-- If you ever add HTTPS tunnel / remote bridge later
Config.AllowHttps = true

-- Health path used for discovery/endpoint learning (Transport will call it)
Config.HealthPath = "/health"

-- Optional: server may expose current scope so curl testing can auto-detect
-- (your app.py already has /scope/current in the latest logs)
Config.ScopeCurrentPath = "/scope/current"

-- =========================================
-- Networking / Rate Safety (Roblox HttpService limits)
-- =========================================
-- Generic request timeout (non-wait)
Config.HttpTimeoutSec = 15

-- Server supports long-poll (timeoutSec). Prefer long-poll to avoid request spam.
Config.WaitLongPollSec = 25

-- If /wait returns 204 (NoTx), we do a small delay BEFORE next wait.
-- Keep this non-zero to avoid "Number of requests exceeded limit".
Config.WaitNoTxDelaySec = 0.35

-- Add jitter so multiple Studio windows don’t sync-poll in lockstep.
Config.WaitNoTxJitterSec = 0.15

-- Backoff when server/network errors (server down, connect fail, etc.)
Config.ErrorBackoffSec = 1.0
Config.ErrorBackoffMaxSec = 8.0

-- Heartbeat interval (smaller than server TTL)
Config.HeartbeatIntervalSec = 5
Config.HeartbeatJitterSec = 0.5

-- Claim TTL should match server CLAIM expiry
Config.ClaimTtlSec = 30
Config.ClaimRetryDelaySec = 0.5

-- Optional hard guardrails (Transport can use later)
Config.RequestBudget = {
	-- If you ever add local rate limiting in Transport, these are the knobs.
	-- Defaults are conservative for Studio.
	MaxRequestsPerMinute = 200, -- soft cap (local enforcement optional)
	Burst = 20,
}

-- =========================================
-- UX / Diagnostics
-- =========================================
Config.LogBufferLines = 2000
Config.MaxPreviewChars = 120000 -- prevents UI lag if huge JSON comes back

-- Optional verbosity flags (used later; safe to ignore now)
Config.Diagnostics = {
	EnableScopeLogs = true,     -- you’re already printing SCOPE lines in Main
	EnableHttpTraces = false,   -- only enable when debugging HTTP problems
	EnablePerfStats = false,    -- future: timings per wait/apply/export
}

-- =========================================
-- Hardening Limits (Safety)
-- =========================================
Config.MaxActionsPerTx = 250

-- ~250KB per script replace (tunable)
Config.MaxSourceBytes = 250000

-- Extra safety knobs (we’ll enforce via FastChecks + Executor later)
Config.Safety = {
	-- Allowed roots for Path.resolve targets (FastChecks will warn/block)
	AllowedRoots = { "Workspace", "ReplicatedStorage", "ServerScriptService", "StarterPlayer", "StarterGui" },

	-- Safer default: do NOT allow deleting core services unless explicitly enabled
	AllowServiceDeletes = false,

	-- Protect plugin’s own container if you mount anything into the DataModel
	ProtectInternalRootName = "PersponifyStudioAI",
}

-- =========================================
-- Context Export (Pre-context)
-- =========================================
Config.Features = {
	-- Executor supports alias normalization (CreateFolder -> createInstance etc.)
	ActionAliases = true,

	-- Include placeId + studioSessionId everywhere (prevents cross-Studio bleed)
	ScopedSessions = true,

	-- Enforce monotonic since cursor (prevents re-applying old tx)
	SinceCursor = true,

	-- Enable context export pipeline (server /context/*)
	ContextExport = true,

	-- Future: only write script.Source if changed (diff-based writes)
	SmartScriptWrites = true,

	-- Future: allow plan-mode nested actions (tx.plan.actions)
	PlanModeShapes = true,
}

-- Throttle exports so you never hit Roblox request limits.
Config.ContextExportMinIntervalSec = 12

-- Capped so payloads stay safe + fast
Config.ContextExportMaxScriptChars = 80000
Config.ContextExportMaxTotalChars = 200000

-- Default project key strategy (used by Context module later)
-- "place" = placeId only, "session" = session id only, "place+session" = safest
Config.ContextProjectKeyStrategy = "place+session"

-- =========================================
-- Helper utilities (safe, optional)
-- =========================================
local function clamp(n, lo, hi)
	if n < lo then return lo end
	if n > hi then return hi end
	return n
end

-- Returns a safe NoTx delay (adds jitter)
function Config.getNoTxDelay()
	local base = tonumber(Config.WaitNoTxDelaySec) or 0.35
	local jitter = tonumber(Config.WaitNoTxJitterSec) or 0.0
	if jitter <= 0 then
		return base
	end
	-- Roblox has Random; safe to use here.
	local r = (Random.new():NextNumber(-jitter, jitter))
	return clamp(base + r, 0.15, 5.0)
end

function Config.getHeartbeatDelay()
	local base = tonumber(Config.HeartbeatIntervalSec) or 5
	local jitter = tonumber(Config.HeartbeatJitterSec) or 0.0
	if jitter <= 0 then
		return base
	end
	local r = (Random.new():NextNumber(-jitter, jitter))
	return clamp(base + r, 1.0, 30.0)
end

return Config


==========================================================================================
FILE: game/ReplicatedStorage/PersponifyStudioAI/Core/Connection
CLASS: ModuleScript
BYTES: 5510
SHA1: len=5510|a=46343|b=16637
------------------------------------------------------------------------------------------
-- Core/Connection.lua
local HttpService = game:GetService("HttpService")
local Config = require(script.Parent.Config)

local Connection = {}
Connection.__index = Connection

local function trimTrailingSlash(url: string): string
	if typeof(url) ~= "string" then return "" end
	return (url:gsub("/+$", ""))
end

local function startsWith(s: string, prefix: string): boolean
	return typeof(s) == "string" and string.sub(s, 1, #prefix) == prefix
end

local function isUrlAllowed(url: string): boolean
	url = tostring(url or "")
	if url == "" then return false end
	if startsWith(url, "https://") and not Config.AllowHttps then
		return false
	end
	if not (startsWith(url, "http://") or startsWith(url, "https://")) then
		return false
	end
	return true
end

local function shortBody(body: any, limit: number?): string
	limit = limit or 180
	local s = tostring(body or "")
	if #s <= limit then return s end
	return string.sub(s, 1, limit) .. "…"
end

function Connection.new(log)
	return setmetatable({
		log = log,
		baseUrl = nil,
		rulesVersion = "unknown",

		lastGoodUrl = nil,
		lastGoodRules = nil,

		caps = {
			ok = false,
			rulesVersion = "unknown",
			protocolVersion = nil,
			endpoints = {},
			meta = {},
		},

		lastScope = nil,
	}, Connection)
end

function Connection:getBaseUrl() return self.baseUrl end
function Connection:getRulesVersion() return self.rulesVersion or "unknown" end
function Connection:setRulesVersion(v) self.rulesVersion = v or "unknown" end
function Connection:setBaseUrl(url) self.baseUrl = trimTrailingSlash(url) end
function Connection:getCaps() return self.caps end
function Connection:getLastScope() return self.lastScope end

function Connection:disconnect()
	self.baseUrl = nil
	self.rulesVersion = "unknown"
	self.caps.ok = false
	self.caps.rulesVersion = "unknown"
	self.caps.protocolVersion = nil
	self.caps.endpoints = {}
	self.caps.meta = {}
	self.lastScope = nil
end

-- Internal HTTP helper (GET JSON) — Roblox safe
-- IMPORTANT: HttpService:RequestAsync does NOT support a "Timeout" key.
local function http_get_json(url: string)
	local req = {
		Url = url,
		Method = "GET",
		Headers = { ["Content-Type"] = "application/json" },
	}

	local ok, res = pcall(function()
		return HttpService:RequestAsync(req)
	end)

	if not ok then
		return false, "RequestAsync failed: " .. tostring(res), nil
	end

	local code = res.StatusCode or 0
	if not res.Success then
		return false, ("HTTP %d: %s"):format(code, shortBody(res.Body)), code
	end

	if not res.Body or res.Body == "" then
		return true, nil, code
	end

	local ok2, decoded = pcall(function()
		return HttpService:JSONDecode(res.Body)
	end)

	if not ok2 then
		return false, "JSONDecode failed: " .. shortBody(decoded), code
	end

	return true, decoded, code
end

local function getHealthPath()
	return tostring(Config.HealthPath or "/health")
end

local function getScopePath()
	return tostring(Config.ScopeCurrentPath or "/scope/current")
end

local function learnCapsFromHealth(self, healthPayload)
	if typeof(healthPayload) ~= "table" then return end
	self.caps.ok = healthPayload.ok == true
	self.caps.rulesVersion = tostring(healthPayload.rulesVersion or "unknown")
	self.caps.protocolVersion = healthPayload.protocolVersion

	if typeof(healthPayload.endpoints) == "table" then
		self.caps.endpoints = healthPayload.endpoints
	else
		self.caps.endpoints = {}
	end

	if typeof(healthPayload.meta) == "table" then
		self.caps.meta = healthPayload.meta
	else
		self.caps.meta = {}
	end
end

function Connection:refreshServerScope()
	if not self.baseUrl then
		return false, "NoBaseUrl"
	end

	local url = self.baseUrl .. getScopePath()
	local ok, res = http_get_json(url)
	if not ok then
		return false, res
	end

	if typeof(res) ~= "table" then
		return false, "Bad scope response"
	end

	if typeof(res.primary) == "table" then
		self.lastScope = {
			leaseToken = res.primary.leaseToken,
			fence = res.primary.fence,
			placeId = res.primary.placeId,
			studioSessionId = res.primary.studioSessionId,
			clientId = res.primary.clientId,
		}
		return true, self.lastScope
	end

	return false, "NoPrimary"
end

function Connection:discover()
	local failures = {}

	local function tryBase(base: string)
		local url = trimTrailingSlash(base)
		if not isUrlAllowed(url) then
			return false, "BlockedUrl", nil
		end

		local healthUrl = url .. getHealthPath()
		local ok, res, code = http_get_json(healthUrl)

		if ok and typeof(res) == "table" and res.ok then
			self.baseUrl = url
			self.rulesVersion = res.rulesVersion or "unknown"
			self.lastGoodUrl = url
			self.lastGoodRules = self.rulesVersion

			learnCapsFromHealth(self, res)
			return true, url, nil
		end

		local detail = ok and "bad payload" or tostring(res)
		return false, ("%s (code=%s)"):format(detail, tostring(code or "?")), code
	end

	if self.lastGoodUrl then
		local ok, urlOrErr = tryBase(self.lastGoodUrl)
		if ok then
			return true, self.baseUrl
		else
			table.insert(failures, ("cached %s → %s"):format(trimTrailingSlash(self.lastGoodUrl), tostring(urlOrErr)))
		end
	end

	for _, base in ipairs(Config.DefaultBaseUrls) do
		local ok, urlOrErr = tryBase(base)
		if ok then
			return true, self.baseUrl
		else
			table.insert(failures, ("%s → %s"):format(trimTrailingSlash(base), tostring(urlOrErr)))
		end
	end

	self.baseUrl = nil
	self.rulesVersion = "unknown"
	self.caps.ok = false

	local summary = "Discover failed. Tried:\n- " .. table.concat(failures, "\n- ")
	return false, summary
end

return Connection


==========================================================================================
FILE: game/ReplicatedStorage/PersponifyStudioAI/Core/ContextExporter
CLASS: ModuleScript
BYTES: 7013
SHA1: len=7013|a=40593|b=60169
------------------------------------------------------------------------------------------
-- Core/ContextExporter.lua
-- Builds a safe "context export" snapshot for the local companion server.
-- Goal: give the AI pre-context so it can edit instead of duplicating.

local Config = require(script.Parent.Config)

local ContextExporter = {}
ContextExporter.__index = ContextExporter

-- Hard safety caps (avoid request limit + UI lag + huge payloads)
local MAX_SCRIPTS = 250
local MAX_TREE_NODES = 2000
local MAX_SCRIPT_SOURCE_CHARS = (Config.ContextExportMaxScriptChars or 80000)
local MAX_TOTAL_SOURCE_CHARS = (Config.ContextExportMaxTotalChars or 200000)

local function isScript(inst)
	return inst:IsA("Script") or inst:IsA("LocalScript") or inst:IsA("ModuleScript")
end

local function safeStr(v)
	if v == nil then return "nil" end
	return tostring(v)
end

-- -------------------------
-- Roots selection (Config-driven, safe fallback)
-- -------------------------
local function getServiceSafe(name)
	local ok, svc = pcall(function()
		return game:GetService(name)
	end)
	if ok then return svc end
	return nil
end

local function buildRoots()
	-- Prefer Config.Safety.AllowedRoots (strings like "Workspace", "ReplicatedStorage", ...)
	local safety = Config.Safety
	if typeof(safety) == "table" and typeof(safety.AllowedRoots) == "table" and #safety.AllowedRoots > 0 then
		local roots = {}
		for _, r in ipairs(safety.AllowedRoots) do
			if r == "Workspace" then
				table.insert(roots, workspace)
			elseif typeof(r) == "string" then
				local svc = getServiceSafe(r)
				if svc then table.insert(roots, svc) end
			end
		end
		if #roots > 0 then
			return roots
		end
	end

	-- Fallback: broad Studio-safe roots (max usefulness)
	return {
		workspace,
		getServiceSafe("ReplicatedStorage"),
		getServiceSafe("ReplicatedFirst"),
		getServiceSafe("ServerScriptService"),
		getServiceSafe("ServerStorage"),
		getServiceSafe("StarterPlayer"),
		getServiceSafe("StarterGui"),
		getServiceSafe("StarterPack"),
		getServiceSafe("Lighting"),
		getServiceSafe("SoundService"),
		getServiceSafe("Teams"),
		getServiceSafe("TextChatService"),
	}
end

-- -------------------------
-- Path building (stable + cache)
-- -------------------------
local _pathCache = {} -- [Instance] = "Root/Child/..."
local function pathOf(inst)
	if inst == nil then return "nil" end
	local cached = _pathCache[inst]
	if cached ~= nil then
		return cached
	end

	-- Build by walking parents (avoids GetFullName ambiguity)
	local parts = {}
	local cur = inst
	while cur do
		table.insert(parts, 1, cur.Name)
		cur = cur.Parent
	end

	-- Normalize DataModel name to "game"
	if #parts > 0 and parts[1] == game.Name then
		parts[1] = "game"
	end

	local p = table.concat(parts, "/")
	_pathCache[inst] = p
	return p
end

-- Cheap non-crypto fingerprint (good enough for "changed or not" signals)
local function cheapFingerprint(s)
	if typeof(s) ~= "string" then s = "" end
	local n = #s
	local a, b = 0, 0
	local limit = math.min(n, 2048)
	for i = 1, limit do
		local c = string.byte(s, i) or 0
		a = (a + c) % 65535
		b = (b + a) % 65535
	end
	return string.format("len=%d|a=%d|b=%d", n, a, b)
end

local function readSourceSafe(scriptInst)
	local ok, got = pcall(function()
		return scriptInst.Source
	end)
	if ok and typeof(got) == "string" then
		return got
	end
	return ""
end

function ContextExporter.new(log)
	return setmetatable({
		log = log,
	}, ContextExporter)
end

-- Builds:
-- {
--   projectKey="default",
--   meta={...},
--   tree=[{path,className,parentPath?,children?}],
--   scripts=[{path,className,sha1,bytes,source?}],
-- }
function ContextExporter:buildSnapshot(projectKey, meta)
	projectKey = projectKey or "default"
	meta = meta or {}

	-- Reset cache per snapshot (prevents stale paths if hierarchy changes)
	_pathCache = {}

	local ROOTS = buildRoots()

	local tree = {}
	local scripts = {}

	local nodeCount = 0
	local scriptCount = 0
	local totalSourceChars = 0

	-- If we hit total cap, we still continue listing scripts as meta-only (no source)
	local totalCapHit = false
	local scriptSourceOmittedCount = 0

	local function addTreeNode(inst, parentPathStr)
		if nodeCount >= MAX_TREE_NODES then return end
		nodeCount = nodeCount + 1

		local p = pathOf(inst)
		local childrenCount = 0
		local ok, kids = pcall(function() return inst:GetChildren() end)
		if ok and typeof(kids) == "table" then
			childrenCount = #kids
		end

		table.insert(tree, {
			path = p,
			className = inst.ClassName,
			parentPath = parentPathStr,
			children = childrenCount,
		})
	end

	local function addScript(inst)
		if scriptCount >= MAX_SCRIPTS then return end

		local src = readSourceSafe(inst)
		local fullLen = #src

		-- Per-script cap (for the payload)
		local payloadSrc = src
		if #payloadSrc > MAX_SCRIPT_SOURCE_CHARS then
			payloadSrc = payloadSrc:sub(1, MAX_SCRIPT_SOURCE_CHARS) .. "\n--[[ TRUNCATED BY ContextExporter ]]"
		end

		local sha = cheapFingerprint(src)
		local p = pathOf(inst)

		-- Total cap logic:
		-- If we can fit it, include source. Otherwise, include meta-only (sha/bytes) and omit source.
		if (not totalCapHit) and (totalSourceChars + #payloadSrc <= MAX_TOTAL_SOURCE_CHARS) then
			totalSourceChars = totalSourceChars + #payloadSrc
			table.insert(scripts, {
				path = p,
				className = inst.ClassName,
				sha1 = sha,
				bytes = fullLen,
				source = payloadSrc,
			})
		else
			totalCapHit = true
			scriptSourceOmittedCount = scriptSourceOmittedCount + 1
			table.insert(scripts, {
				path = p,
				className = inst.ClassName,
				sha1 = sha,
				bytes = fullLen,
				source = nil, -- allowed by server schema (optional)
			})
		end

		scriptCount = scriptCount + 1
	end

	local function walk(rootInst)
		if not rootInst then return end

		addTreeNode(rootInst, nil)

		local function dfs(inst)
			if nodeCount >= MAX_TREE_NODES then return end

			local parentP = pathOf(inst)
			local ok, kids = pcall(function() return inst:GetChildren() end)
			if not ok or typeof(kids) ~= "table" then return end

			for _, child in ipairs(kids) do
				if nodeCount >= MAX_TREE_NODES then return end

				addTreeNode(child, parentP)

				if isScript(child) then
					addScript(child)
					if scriptCount >= MAX_SCRIPTS then
						-- Still continue tree, but stop script collection
						-- (tree is often more valuable for structure)
					end
				end

				dfs(child)
			end
		end

		dfs(rootInst)
	end

	for _, r in ipairs(ROOTS) do
		if r then
			walk(r)
		end
	end

	-- Meta includes caps so server / AI knows snapshot completeness
	meta.exporter = meta.exporter or "plugin-context-exporter"
	meta.maxScripts = MAX_SCRIPTS
	meta.maxTreeNodes = MAX_TREE_NODES
	meta.maxScriptChars = MAX_SCRIPT_SOURCE_CHARS
	meta.maxTotalChars = MAX_TOTAL_SOURCE_CHARS
	meta.treeCount = #tree
	meta.scriptCount = #scripts
	meta.totalSourceChars = totalSourceChars
	meta.totalCapHit = totalCapHit
	meta.scriptSourceOmittedCount = scriptSourceOmittedCount
	meta.builtAt = os.time()

	return {
		projectKey = projectKey,
		meta = meta,
		tree = tree,
		scripts = scripts,
	}
end

return ContextExporter


==========================================================================================
FILE: game/ReplicatedStorage/PersponifyStudioAI/Core/DebugLog
CLASS: ModuleScript
BYTES: 7182
SHA1: len=7182|a=30368|b=28055
------------------------------------------------------------------------------------------
-- Core/DebugLog.lua
-- Persponify Studio AI - DebugLog
-- Goals:
--  - Capped log buffer
--  - Stable getText()
--  - Structured entries (future-safe)
--  - Optional push listeners (UI can subscribe)
--  - Optional delta API (UI can append instead of full rebuild)
--  - Backwards compatible: log:add("message") still works

local DebugLog = {}
DebugLog.__index = DebugLog

-- ============================
-- Utilities
-- ============================
local function nowStamp()
	local t = os.date("*t")
	return string.format("%04d-%02d-%02d %02d:%02d:%02d",
		t.year, t.month, t.day, t.hour, t.min, t.sec
	)
end

local function safeStr(v)
	if v == nil then return "nil" end
	return tostring(v)
end

local LEVEL_RANK = { TRACE=1, DEBUG=2, INFO=3, WARN=4, ERROR=5 }

local function normalizeLevel(level)
	level = tostring(level or "INFO"):upper()
	if LEVEL_RANK[level] == nil then
		return "INFO"
	end
	return level
end

local function levelAllowed(minLevel, level)
	local a = LEVEL_RANK[tostring(minLevel or "TRACE")] or 1
	local b = LEVEL_RANK[tostring(level or "INFO")] or 3
	return b >= a
end

local function normalizeEntry(input, defaultTag)
	-- Accept:
	--  1) string/number/etc -> becomes message
	--  2) table {msg=..., level=..., tag=..., ts=...}
	if typeof(input) == "table" then
		local msg = input.msg
		if msg == nil then msg = input.message end
		msg = safeStr(msg)

		return {
			ts = input.ts or nowStamp(),
			level = normalizeLevel(input.level),
			tag = (input.tag ~= nil and safeStr(input.tag)) or defaultTag,
			msg = msg,
		}
	end

	return {
		ts = nowStamp(),
		level = "INFO",
		tag = defaultTag,
		msg = safeStr(input),
	}
end

local function formatEntry(e)
	-- Stable output format:
	-- YYYY-MM-DD HH:MM:SS [LEVEL] [Tag] message
	local tag = ""
	if e.tag and e.tag ~= "" then
		tag = ("[%s] "):format(e.tag)
	end
	return string.format("%s [%s] %s%s", e.ts, e.level, tag, e.msg)
end

-- ============================
-- DebugLog
-- ============================
function DebugLog.new(maxLines)
	local self = setmetatable({}, DebugLog)

	self.maxLines = maxLines or 1000

	-- Ring buffer storage
	self._entries = table.create(self.maxLines)
	self._lines = table.create(self.maxLines)
	self._head = 1
	self._count = 0

	-- Combined view
	self._cachedText = ""
	self._dirty = true

	-- Monotonic sequence
	self._seq = 0

	-- Listener support (push updates)
	self._listeners = {}
	self._listenerMinInterval = 0.05
	self._lastListenerTick = 0

	-- Filters / defaults
	self.minLevel = "TRACE"
	self.defaultTag = nil

	return self
end

-- Backwards compatible API: add("hello") OR add({level="WARN", tag="X", msg="..."})
function DebugLog:add(msgOrEntry)
	local e = normalizeEntry(msgOrEntry, self.defaultTag)
	if not levelAllowed(self.minLevel, e.level) then
		return
	end

	self._seq += 1
	e.seq = self._seq

	local line = formatEntry(e)

	-- Insert into ring
	if self._count < self.maxLines then
		local idx = ((self._head + self._count - 1) % self.maxLines) + 1
		self._entries[idx] = e
		self._lines[idx] = line
		self._count += 1

		-- Fast append to cached text (no rebuild)
		if self._cachedText == "" then
			self._cachedText = line
		else
			self._cachedText ..= "\n" .. line
		end
		self._dirty = false
	else
		-- Overwrite head when full
		self._entries[self._head] = e
		self._lines[self._head] = line
		self._head = (self._head % self.maxLines) + 1

		-- Once we overwrite, we can't cheaply "drop first line" from a string.
		-- Mark dirty and rebuild on next getText().
		self._dirty = true
	end

	-- Notify listeners (rate-limited, safe)
	if #self._listeners > 0 then
		local now = os.clock()
		if (now - self._lastListenerTick) >= self._listenerMinInterval then
			self._lastListenerTick = now
			for _, cb in ipairs(self._listeners) do
				pcall(cb, e, line)
			end
		end
	end
end

function DebugLog:clear()
	self._entries = table.create(self.maxLines)
	self._lines = table.create(self.maxLines)
	self._head = 1
	self._count = 0
	self._cachedText = ""
	self._dirty = false
	self._seq = 0
end

-- Returns full text (rebuilds only when needed)
function DebugLog:getText()
	if not self._dirty then
		return self._cachedText
	end

	-- Rebuild from ring in logical order
	local out = table.create(self._count)
	for i = 1, self._count do
		local idx = ((self._head + i - 2) % self.maxLines) + 1
		out[i] = self._lines[idx]
	end

	self._cachedText = table.concat(out, "\n")
	self._dirty = false
	return self._cachedText
end

-- ============================
-- Advanced QoL
-- ============================

-- Push-style subscription
function DebugLog:onChanged(callback)
	if typeof(callback) ~= "function" then
		return function() end
	end

	table.insert(self._listeners, callback)

	-- Return unsubscribe
	return function()
		for i, cb in ipairs(self._listeners) do
			if cb == callback then
				table.remove(self._listeners, i)
				break
			end
		end
	end
end

function DebugLog:addMany(list)
	if typeof(list) ~= "table" then return end
	for i = 1, #list do
		self:add(list[i])
	end
end

function DebugLog:setMinLevel(level)
	self.minLevel = normalizeLevel(level)
end

function DebugLog:setListenerThrottle(sec)
	if typeof(sec) ~= "number" then return end
	self._listenerMinInterval = math.max(0, sec)
end

-- Delta API:
-- UI can call getDelta(lastSeq) to avoid full getText() rebuild every tick.
-- Returns:
--   deltaText, newSeq, ok
-- If ok==false, UI should fall back to getText() (delta no longer available).
function DebugLog:getDelta(lastSeq)
	lastSeq = tonumber(lastSeq) or 0

	-- If nothing new
	if lastSeq >= self._seq then
		return "", self._seq, true
	end

	-- If buffer empty
	if self._count == 0 then
		return "", self._seq, true
	end

	-- Oldest seq we still have (best effort)
	local oldest = nil
	do
		local firstIdx = self._head
		local firstEntry = self._entries[firstIdx]
		if firstEntry and typeof(firstEntry) == "table" then
			oldest = tonumber(firstEntry.seq)
		end
	end

	-- If we can't determine oldest, force full refresh
	if not oldest then
		return "", self._seq, false
	end

	-- If caller is too far behind, delta is unsafe
	if lastSeq < oldest - 1 then
		return "", self._seq, false
	end

	-- Collect new lines (seq > lastSeq)
	local out = {}
	for i = 1, self._count do
		local idx = ((self._head + i - 2) % self.maxLines) + 1
		local e = self._entries[idx]
		if e and tonumber(e.seq) and tonumber(e.seq) > lastSeq then
			table.insert(out, self._lines[idx])
		end
	end

	return table.concat(out, "\n"), self._seq, true
end

-- Scoped logger
function DebugLog:scope(tag)
	tag = safeStr(tag)
	local parent = self

	local scoped = {}

	function scoped:trace(msg) parent:add({level="TRACE", tag=tag, msg=msg}) end
	function scoped:debug(msg) parent:add({level="DEBUG", tag=tag, msg=msg}) end
	function scoped:info(msg)  parent:add({level="INFO",  tag=tag, msg=msg}) end
	function scoped:warn(msg)  parent:add({level="WARN",  tag=tag, msg=msg}) end
	function scoped:error(msg) parent:add({level="ERROR", tag=tag, msg=msg}) end

	function scoped:add(v)
		if typeof(v) == "table" then
			v.tag = v.tag or tag
			parent:add(v)
		else
			parent:add({level="INFO", tag=tag, msg=v})
		end
	end

	return scoped
end

return DebugLog


==========================================================================================
FILE: game/ReplicatedStorage/PersponifyStudioAI/Core/Executor
CLASS: ModuleScript
BYTES: 23187
SHA1: len=23187|a=42071|b=12837
------------------------------------------------------------------------------------------
-- Core/Executor.lua
-- Persponify Studio AI - Executor (v1 compatible, vNext-ready)
-- Upgrades (non-breaking):
--  - Better rollback (reparent + rename + script + props + created)
--  - Optional safety guardrails (Config.Safety)
--  - Optional SmartScriptWrites (Config.Features.SmartScriptWrites)
--  - Optional plan-mode nested actions (tx.plan.actions)
--  - Scoped logger support (DebugLog:scope)

local ChangeHistoryService = game:GetService("ChangeHistoryService")

local Config = require(script.Parent.Config)
local Path = require(script.Parent.Path)

local Executor = {}
Executor.__index = Executor

-- =========================
-- Helpers
-- =========================
local function isScript(inst)
	return inst:IsA("Script") or inst:IsA("LocalScript") or inst:IsA("ModuleScript")
end

local function safeStr(v)
	if v == nil then return "nil" end
	return tostring(v)
end

local function lowerType(t)
	if typeof(t) ~= "string" then return "" end
	return string.lower(t)
end

local function getActions(tx)
	if typeof(tx) ~= "table" then return nil end
	if typeof(tx.actions) == "table" then return tx.actions end
	if typeof(tx.plan) == "table" and typeof(tx.plan.actions) == "table" then
		return tx.plan.actions
	end
	return nil
end

local function clamp(n, lo, hi)
	if n < lo then return lo end
	if n > hi then return hi end
	return n
end

local function splitLines(s)
	s = tostring(s or "")
	s = s:gsub("\r\n", "\n")
	local out = {}
	local i = 1
	while true do
		local j = string.find(s, "\n", i, true)
		if not j then
			table.insert(out, string.sub(s, i))
			break
		end
		table.insert(out, string.sub(s, i, j - 1))
		i = j + 1
	end
	return out
end

local function joinLines(lines)
	return table.concat(lines, "\n")
end

local function trySetProperty(inst, prop, value)
	local ok, err = pcall(function()
		inst[prop] = value
	end)
	return ok, err
end

local function getChildByName(parent, name)
	if not parent or typeof(name) ~= "string" or name == "" then return nil end
	return parent:FindFirstChild(name)
end

local function bytesOfString(s)
	s = tostring(s or "")
	return #s
end

-- =========================
-- Safety guardrails (Config.Safety)
-- =========================
local function isServiceInstance(inst)
	-- Heuristic: DataModel services generally have Parent == game
	-- (Workspace is also a service)
	return inst and inst.Parent == game
end

local function isProtectedByConfig(inst)
	local safety = Config.Safety
	if typeof(safety) ~= "table" then
		return false, nil
	end

	-- Prevent deleting core services unless explicitly allowed
	if safety.AllowServiceDeletes == false and isServiceInstance(inst) then
		return true, "Service deletes blocked by Config.Safety.AllowServiceDeletes=false"
	end

	-- Optional: protect a specific internal root by name
	local protectName = safety.ProtectInternalRootName
	if typeof(protectName) == "string" and protectName ~= "" then
		-- If the target itself is that root or is inside it, block deletes
		local cur = inst
		while cur do
			if cur.Name == protectName then
				return true, ("Protected internal root blocked: %s"):format(protectName)
			end
			cur = cur.Parent
		end
	end

	return false, nil
end

-- =========================
-- Action Normalization
-- =========================
local function normalizeAction(action)
	if typeof(action) ~= "table" then
		return nil, "Invalid action (not a table)"
	end

	local a = {}
	for k, v in pairs(action) do
		a[k] = v
	end

	local rawType = a.type
	local t = lowerType(rawType)

	local aliasesOn = (Config.Features and Config.Features.ActionAliases) ~= false

	local function parentPath()
		return a.parentPath or a.parent or a.parent_path
	end

	local function targetPath()
		return a.path or a.target or a.targetPath or a.target_path
	end

	if aliasesOn then
		if t == "createfolder" then
			return {
				type = "createInstance",
				parentPath = parentPath(),
				className = "Folder",
				name = a.name,
				ifExists = a.ifExists,
			}
		end

		if t == "createmodulescript" then
			return {
				type = "createInstance",
				parentPath = parentPath(),
				className = "ModuleScript",
				name = a.name,
				source = a.source,
				ifExists = a.ifExists,
			}
		end

		if t == "createinstance" or t == "create_instance" then
			return {
				type = "createInstance",
				parentPath = parentPath(),
				className = a.className or a.class or a.class_name,
				name = a.name,
				source = a.source,
				ifExists = a.ifExists,
			}
		end

		if t == "setproperty" or t == "set_property" then
			return {
				type = "setProperty",
				path = targetPath(),
				property = a.property,
				value = a.value,
			}
		end

		if t == "setproperties" or t == "set_properties" or t == "batchsetproperties" then
			return {
				type = "setProperties",
				path = targetPath(),
				properties = a.properties or a.props or a.values,
			}
		end

		if t == "deleteinstance" or t == "delete_instance" then
			return {
				type = "deleteInstance",
				path = targetPath(),
				mode = a.mode,
			}
		end

		if t == "renameinstance" or t == "rename_instance" then
			return {
				type = "renameInstance",
				path = targetPath(),
				newName = a.newName or a.name,
			}
		end

		if t == "moveinstance" or t == "move_instance" or t == "setparent" or t == "set_parent" then
			return {
				type = "moveInstance",
				path = targetPath(),
				newParentPath = a.newParentPath or a.parentPath or a.parent,
				ifExists = a.ifExists,
			}
		end

		if t == "setattribute" or t == "set_attribute" then
			return {
				type = "setAttribute",
				path = targetPath(),
				key = a.key or a.name,
				value = a.value,
			}
		end

		if t == "setattributes" or t == "set_attributes" then
			return {
				type = "setAttributes",
				path = targetPath(),
				attributes = a.attributes or a.props or a.values,
			}
		end

		if t == "editscript" or t == "edit_script" then
			return {
				type = "editScript",
				path = targetPath(),
				mode = a.mode or "replace",
				source = a.source,
				lineStart = a.lineStart,
				lineEnd = a.lineEnd,
				anchor = a.anchor,
			}
		end
	end

	-- Canonical already
	if rawType == "createInstance" then
		return {
			type = "createInstance",
			parentPath = a.parentPath,
			className = a.className,
			name = a.name,
			source = a.source,
			ifExists = a.ifExists,
		}
	end

	if rawType == "setProperty" then
		return { type = "setProperty", path = a.path, property = a.property, value = a.value }
	end

	if rawType == "setProperties" then
		return { type = "setProperties", path = a.path, properties = a.properties }
	end

	if rawType == "deleteInstance" then
		return { type = "deleteInstance", path = a.path, mode = a.mode }
	end

	if rawType == "renameInstance" then
		return { type = "renameInstance", path = a.path, newName = a.newName }
	end

	if rawType == "moveInstance" then
		return { type = "moveInstance", path = a.path, newParentPath = a.newParentPath, ifExists = a.ifExists }
	end

	if rawType == "setAttribute" then
		return { type = "setAttribute", path = a.path, key = a.key, value = a.value }
	end

	if rawType == "setAttributes" then
		return { type = "setAttributes", path = a.path, attributes = a.attributes }
	end

	if rawType == "editScript" then
		return {
			type = "editScript",
			path = a.path,
			mode = a.mode or "replace",
			source = a.source,
			lineStart = a.lineStart,
			lineEnd = a.lineEnd,
			anchor = a.anchor,
		}
	end

	return { type = typeof(rawType) == "string" and rawType or "Unknown", _raw = a }, nil
end

-- =========================
-- Executor
-- =========================
function Executor.new(logger)
	local self = setmetatable({
		log = logger,
		_slog = nil,
	}, Executor)

	-- If DebugLog supports scope()
	if logger and typeof(logger.scope) == "function" then
		self._slog = logger:scope("Executor")
	end

	return self
end

local function LOG(self, level, msg)
	if self._slog then
		if level == "WARN" then self._slog:warn(msg)
		elseif level == "ERROR" then self._slog:error(msg)
		elseif level == "DEBUG" then self._slog:debug(msg)
		elseif level == "TRACE" then self._slog:trace(msg)
		else self._slog:info(msg) end
	else
		self.log:add(msg)
	end
end

function Executor:preflight(tx)
	if typeof(tx) ~= "table" then
		return false, "tx not a table"
	end

	local pv = tx.protocolVersion
	if pv ~= nil and pv ~= Config.ProtocolVersion then
		return false, ("Protocol mismatch (tx=%s, expected=%s)"):format(safeStr(pv), safeStr(Config.ProtocolVersion))
	end

	local actions = getActions(tx)
	if typeof(actions) ~= "table" then
		return false, "Missing actions[]"
	end

	local maxActions = Config.MaxActionsPerTx or 250
	if #actions > maxActions then
		return false, ("Too many actions (%d > %d)"):format(#actions, maxActions)
	end

	local maxSource = Config.MaxSourceBytes or 250000
	for i, a in ipairs(actions) do
		if typeof(a) == "table" then
			local src = a.source
			if src ~= nil then
				local b = bytesOfString(src)
				if b > maxSource then
					return false, ("Action %d source too large (%d > %d bytes)"):format(i, b, maxSource)
				end
			end
		end
	end

	return true, nil
end

function Executor:apply(tx)
	local txId = safeStr(tx and (tx.transactionId or tx.id) or "unknown")
	local actions = getActions(tx) or {}

	local opts = (typeof(tx) == "table" and typeof(tx.options) == "table") and tx.options or {}
	local continueOnError = (opts.continueOnError == true)
	local rollbackOnError = (opts.rollbackOnError ~= false)

	-- Resolve cache per tx (faster + more stable)
	local resolveCache = {}
	local function resolveCached(pathStr)
		if typeof(pathStr) ~= "string" or pathStr == "" then
			return nil, "BadPath"
		end
		if resolveCache[pathStr] ~= nil then
			return resolveCache[pathStr].inst, resolveCache[pathStr].err
		end
		local inst, err = Path.resolve(pathStr)
		resolveCache[pathStr] = { inst = inst, err = err }
		return inst, err
	end

	-- Rollback journal
	local journal = {
		created = {},
		propChanges = {},
		scriptEdits = {},
		renames = {},
		reparents = {},
		_propKey = {},
		_scriptKey = {},
		_renameKey = {},
		_reparentKey = {},
	}

	local function journalProp(inst, prop)
		local key = inst:GetDebugId(0) .. "::" .. prop
		if journal._propKey[key] then return end
		journal._propKey[key] = true

		local ok, old = pcall(function() return inst[prop] end)
		if ok then
			table.insert(journal.propChanges, { inst = inst, prop = prop, oldValue = old })
		end
	end

	local function journalScript(inst)
		local key = inst:GetDebugId(0)
		if journal._scriptKey[key] then return end
		journal._scriptKey[key] = true

		local ok, old = pcall(function() return inst.Source end)
		if ok then
			table.insert(journal.scriptEdits, { inst = inst, oldSource = old })
		end
	end

	local function journalRename(inst)
		local key = inst:GetDebugId(0)
		if journal._renameKey[key] then return end
		journal._renameKey[key] = true
		table.insert(journal.renames, { inst = inst, oldName = inst.Name })
	end

	local function journalReparent(inst)
		local key = inst:GetDebugId(0)
		if journal._reparentKey[key] then return end
		journal._reparentKey[key] = true
		table.insert(journal.reparents, { inst = inst, oldParent = inst.Parent })
	end

	local function rollback()
		LOG(self, "WARN", "Rollback: attempting best-effort undo...")

		-- Reparent back (reverse order)
		for i = #journal.reparents, 1, -1 do
			local r = journal.reparents[i]
			pcall(function()
				if r.inst and r.inst.Parent ~= r.oldParent then
					r.inst.Parent = r.oldParent
				end
			end)
		end

		-- Rename back
		for i = #journal.renames, 1, -1 do
			local r = journal.renames[i]
			pcall(function()
				if r.inst and r.inst.Name ~= r.oldName then
					r.inst.Name = r.oldName
				end
			end)
		end

		-- Script sources back
		for i = #journal.scriptEdits, 1, -1 do
			local r = journal.scriptEdits[i]
			pcall(function()
				if r.inst and isScript(r.inst) then
					r.inst.Source = r.oldSource or ""
				end
			end)
		end

		-- Properties back
		for i = #journal.propChanges, 1, -1 do
			local r = journal.propChanges[i]
			pcall(function()
				if r.inst then
					r.inst[r.prop] = r.oldValue
				end
			end)
		end

		-- Destroy created (reverse order)
		for i = #journal.created, 1, -1 do
			local inst = journal.created[i]
			pcall(function()
				if inst and inst.Parent then
					inst:Destroy()
				end
			end)
		end

		LOG(self, "WARN", "Rollback: done.")
	end

	ChangeHistoryService:SetWaypoint("PersponifyStudioAI:Before:" .. txId)
	LOG(self, "INFO", "Applying tx: " .. txId)

	local applied = {}
	local errors = {}

	local maxSource = Config.MaxSourceBytes or 250000
	local smartWrites = (Config.Features and Config.Features.SmartScriptWrites) == true

	for i, action in ipairs(actions) do
		local ok, err = pcall(function()
			local normalized, nerr = normalizeAction(action)
			if not normalized then
				error(nerr)
			end

			-- Enforce source size
			if (normalized.type == "createInstance" or normalized.type == "editScript") and normalized.source ~= nil then
				local b = bytesOfString(normalized.source)
				if b > maxSource then
					error(("source too large (%d > %d bytes)"):format(b, maxSource))
				end
			end

			local result = self:applyAction(
				normalized,
				resolveCached,
				journal,
				journalProp,
				journalScript,
				journalRename,
				journalReparent,
				smartWrites
			)

			table.insert(applied, { step = i, type = safeStr(normalized.type), result = result })
		end)

		if ok then
			LOG(self, "INFO", ("✅ %d/%d %s"):format(i, #actions, safeStr(action.type)))
		else
			local msg = safeStr(err)
			table.insert(errors, { step = i, type = safeStr(action.type), message = msg })
			LOG(self, "ERROR", ("❌ %d/%d failed: %s"):format(i, #actions, msg))

			if rollbackOnError then
				rollback()
			end

			if not continueOnError then
				break
			end
		end
	end

	ChangeHistoryService:SetWaypoint("PersponifyStudioAI:After:" .. txId)
	return applied, errors
end

function Executor:applyAction(a, resolveCached, journal, journalProp, journalScript, journalRename, journalReparent, smartWrites)
	local t = a.type

	if t == "createInstance" then
		local parentPath = a.parentPath
		if typeof(parentPath) ~= "string" or parentPath == "" then
			error("createInstance missing parentPath")
		end

		local parent, perr = resolveCached(parentPath)
		if not parent then error(perr) end

		local className = a.className
		if typeof(className) ~= "string" or className == "" then
			error("createInstance missing className")
		end

		local name = a.name
		if typeof(name) ~= "string" or name == "" then
			name = className
		end

		local ifExists = tostring(a.ifExists or "skip"):lower()
		if ifExists ~= "skip" and ifExists ~= "error" and ifExists ~= "replace" and ifExists ~= "update" then
			ifExists = "skip"
		end

		local existing = getChildByName(parent, name)
		if existing then
			if ifExists == "skip" then
				return { created = false, reused = true, fullName = existing:GetFullName() }
			elseif ifExists == "error" then
				error(("Instance already exists: %s"):format(existing:GetFullName()))
			elseif ifExists == "replace" then
				local blocked, reason = isProtectedByConfig(existing)
				if blocked then error(reason) end
				existing:Destroy()
				existing = nil
			elseif ifExists == "update" then
				if existing.ClassName ~= className then
					error(("update refused: existing class %s != %s"):format(existing.ClassName, className))
				end
				if isScript(existing) and a.source ~= nil then
					journalScript(existing)
					local newSrc = tostring(a.source)
					if (not smartWrites) or (existing.Source ~= newSrc) then
						existing.Source = newSrc
					end
				end
				return { created = false, updated = true, fullName = existing:GetFullName() }
			end
		end

		local inst = Instance.new(className)
		inst.Name = name
		inst.Parent = parent
		table.insert(journal.created, inst)

		if isScript(inst) and a.source ~= nil then
			journalScript(inst)
			inst.Source = tostring(a.source)
		end

		return { created = true, fullName = inst:GetFullName() }

	elseif t == "setProperty" then
		if typeof(a.path) ~= "string" or a.path == "" then
			error("setProperty missing path")
		end
		local inst, perr = resolveCached(a.path)
		if not inst then error(perr) end

		local prop = a.property
		if typeof(prop) ~= "string" or prop == "" then
			error("setProperty missing property")
		end

		journalProp(inst, prop)

		local okSet, errSet = trySetProperty(inst, prop, a.value)
		if not okSet then error("setProperty failed: " .. safeStr(errSet)) end

		return { updated = true, path = inst:GetFullName(), property = prop }

	elseif t == "setProperties" then
		if typeof(a.path) ~= "string" or a.path == "" then
			error("setProperties missing path")
		end
		local inst, perr = resolveCached(a.path)
		if not inst then error(perr) end

		if typeof(a.properties) ~= "table" then
			error("setProperties missing properties table")
		end

		local changed = {}
		for prop, value in pairs(a.properties) do
			if typeof(prop) == "string" and prop ~= "" then
				journalProp(inst, prop)
				local okSet, errSet = trySetProperty(inst, prop, value)
				if not okSet then
					error(("setProperties failed at %s: %s"):format(prop, safeStr(errSet)))
				end
				table.insert(changed, prop)
			end
		end

		return { updated = true, path = inst:GetFullName(), properties = changed }

	elseif t == "deleteInstance" then
		if typeof(a.path) ~= "string" or a.path == "" then
			error("deleteInstance missing path")
		end
		local inst, perr = resolveCached(a.path)
		if not inst then error(perr) end

		local blocked, reason = isProtectedByConfig(inst)
		if blocked then error(reason) end

		local full = inst:GetFullName()
		local mode = tostring(a.mode or "destroy"):lower()

		if mode == "clearchildren" then
			for _, ch in ipairs(inst:GetChildren()) do
				local b2, r2 = isProtectedByConfig(ch)
				if not b2 then
					ch:Destroy()
				end
			end
			return { cleared = true, path = full }
		end

		inst:Destroy()
		return { deleted = true, path = full }

	elseif t == "renameInstance" then
		if typeof(a.path) ~= "string" or a.path == "" then
			error("renameInstance missing path")
		end
		local inst, perr = resolveCached(a.path)
		if not inst then error(perr) end

		local newName = a.newName
		if typeof(newName) ~= "string" or newName == "" then
			error("renameInstance missing newName")
		end

		journalRename(inst)
		inst.Name = newName
		return { renamed = true, path = inst:GetFullName(), name = inst.Name }

	elseif t == "moveInstance" then
		if typeof(a.path) ~= "string" or a.path == "" then
			error("moveInstance missing path")
		end
		if typeof(a.newParentPath) ~= "string" or a.newParentPath == "" then
			error("moveInstance missing newParentPath")
		end

		local inst, perr = resolveCached(a.path)
		if not inst then error(perr) end

		local newParent, perr2 = resolveCached(a.newParentPath)
		if not newParent then error(perr2) end

		local ifExists = tostring(a.ifExists or "error"):lower()
		if ifExists ~= "skip" and ifExists ~= "error" and ifExists ~= "replace" then
			ifExists = "error"
		end

		local conflict = getChildByName(newParent, inst.Name)
		if conflict and conflict ~= inst then
			if ifExists == "skip" then
				return { moved = false, skipped = true, conflict = conflict:GetFullName() }
			elseif ifExists == "replace" then
				local blocked, reason = isProtectedByConfig(conflict)
				if blocked then error(reason) end
				conflict:Destroy()
			else
				error(("moveInstance conflict: %s already exists under %s"):format(inst.Name, newParent:GetFullName()))
			end
		end

		journalReparent(inst)
		inst.Parent = newParent
		return { moved = true, path = inst:GetFullName(), parent = newParent:GetFullName() }

	elseif t == "setAttribute" then
		if typeof(a.path) ~= "string" or a.path == "" then
			error("setAttribute missing path")
		end
		local inst, perr = resolveCached(a.path)
		if not inst then error(perr) end

		local key = a.key
		if typeof(key) ~= "string" or key == "" then
			error("setAttribute missing key")
		end

		inst:SetAttribute(key, a.value)
		return { attribute = key, updated = true, path = inst:GetFullName() }

	elseif t == "setAttributes" then
		if typeof(a.path) ~= "string" or a.path == "" then
			error("setAttributes missing path")
		end
		local inst, perr = resolveCached(a.path)
		if not inst then error(perr) end

		if typeof(a.attributes) ~= "table" then
			error("setAttributes missing attributes table")
		end

		local keys = {}
		for k, v in pairs(a.attributes) do
			if typeof(k) == "string" and k ~= "" then
				inst:SetAttribute(k, v)
				table.insert(keys, k)
			end
		end

		return { updated = true, path = inst:GetFullName(), attributes = keys }

	elseif t == "editScript" then
		if typeof(a.path) ~= "string" or a.path == "" then
			error("editScript missing path")
		end
		local inst, perr = resolveCached(a.path)
		if not inst then error(perr) end
		if not isScript(inst) then error("Target not a script") end

		local mode = tostring(a.mode or "replace"):lower()
		local newChunk = tostring(a.source or "")

		journalScript(inst)

		if mode == "replace" then
			if (not smartWrites) or (inst.Source ~= newChunk) then
				inst.Source = newChunk
			end
			return { edited = true, path = inst:GetFullName(), mode = "replace" }

		elseif mode == "append" then
			inst.Source = (inst.Source or "") .. newChunk
			return { edited = true, path = inst:GetFullName(), mode = "append" }

		elseif mode == "prepend" then
			inst.Source = newChunk .. (inst.Source or "")
			return { edited = true, path = inst:GetFullName(), mode = "prepend" }

		elseif mode == "replacerange" then
			local ls = tonumber(a.lineStart)
			local le = tonumber(a.lineEnd)
			if not ls or not le then
				error("replaceRange requires lineStart + lineEnd")
			end
			ls = math.max(1, math.floor(ls))
			le = math.max(ls, math.floor(le))

			local lines = splitLines(inst.Source or "")
			ls = clamp(ls, 1, #lines + 1)
			le = clamp(le, 1, #lines)

			local replacement = splitLines(newChunk)
			local out = {}

			for j = 1, ls - 1 do out[#out + 1] = lines[j] end
			for j = 1, #replacement do out[#out + 1] = replacement[j] end
			for j = le + 1, #lines do out[#out + 1] = lines[j] end

			local merged = joinLines(out)
			if (not smartWrites) or (inst.Source ~= merged) then
				inst.Source = merged
			end
			return { edited = true, path = inst:GetFullName(), mode = "replaceRange", lineStart = ls, lineEnd = le }

		elseif mode == "insertafter" or mode == "insertbefore" then
			local anchor = tostring(a.anchor or "")
			if anchor == "" then
				error(mode .. " requires anchor")
			end

			local src = inst.Source or ""
			local pos = string.find(src, anchor, 1, true)
			if not pos then error("anchor not found") end

			local insertPos = (mode == "insertbefore") and pos or (pos + #anchor)
			local merged = string.sub(src, 1, insertPos - 1) .. newChunk .. string.sub(src, insertPos)

			if (not smartWrites) or (inst.Source ~= merged) then
				inst.Source = merged
			end
			return { edited = true, path = inst:GetFullName(), mode = mode, anchor = anchor }

		else
			error("Unsupported editScript mode: " .. safeStr(mode))
		end

	else
		error("Unknown action.type: " .. safeStr(t))
	end
end

return Executor


==========================================================================================
FILE: game/ReplicatedStorage/PersponifyStudioAI/Core/Path
CLASS: ModuleScript
BYTES: 6017
SHA1: len=6017|a=35961|b=64162
------------------------------------------------------------------------------------------
-- Core/Path.lua
-- Safe + fast path resolver for Studio edits.
-- Supports:
--   - Workspace/Foo/Bar
--   - Workspace.Foo.Bar   (optional, configurable)
--   - game/Workspace/Foo  (optional "game root" support)

local Config = require(script.Parent.Config)

local Path = {}

-- =========================
-- Safety / Policy
-- =========================
local ALLOW_GAME_ROOT = true

-- Treat "." as separator ONLY when the user didn't already use "/"
-- (avoids weirdness if someone has dots in names AND is using slash paths)
local TREAT_DOTS_AS_SEPARATORS = true

-- Pull allowlist from Config if available, else fallback
local function buildAllowedRoots()
	local out = {}

	local safety = Config and Config.Safety
	if typeof(safety) == "table" and typeof(safety.AllowedRoots) == "table" and #safety.AllowedRoots > 0 then
		for _, name in ipairs(safety.AllowedRoots) do
			if typeof(name) == "string" and name ~= "" then
				out[name] = true
			end
		end
	else
		-- fallback (your previous list)
		out.Workspace = true
		out.ReplicatedStorage = true
		out.ServerScriptService = true
		out.ServerStorage = true
		out.StarterPlayer = true
		out.StarterGui = true
		out.StarterPack = true
		out.Lighting = true
		out.SoundService = true
	end

	return out
end

local ALLOWED_ROOTS = buildAllowedRoots()

-- =========================
-- Performance: small LRU cache
-- =========================
local CACHE_MAX = 256
local cache = {}       -- key -> Instance
local cacheOrder = {}  -- most-recent at end (simple LRU)

local function cacheTouch(key)
	-- Move key to end if present
	for i = #cacheOrder, 1, -1 do
		if cacheOrder[i] == key then
			table.remove(cacheOrder, i)
			break
		end
	end
	table.insert(cacheOrder, key)
end

local function cachePut(key, value)
	if cache[key] ~= nil then
		cache[key] = value
		cacheTouch(key)
		return
	end

	cache[key] = value
	table.insert(cacheOrder, key)

	while #cacheOrder > CACHE_MAX do
		local old = table.remove(cacheOrder, 1)
		cache[old] = nil
	end
end

local function cacheGet(key)
	local v = cache[key]
	if v ~= nil then
		cacheTouch(key)
	end
	return v
end

-- =========================
-- String utils
-- =========================
local function trim(s)
	s = tostring(s or "")
	s = s:gsub("^%s+", "")
	s = s:gsub("%s+$", "")
	return s
end

local function normalizePath(pathString)
	pathString = trim(pathString)

	-- Windows-style -> forward slashes
	pathString = pathString:gsub("\\", "/")

	-- Collapse double slashes
	pathString = pathString:gsub("/+", "/")

	-- If user didn't use "/", optionally treat "." as separator (Workspace.Foo.Bar)
	if TREAT_DOTS_AS_SEPARATORS and not string.find(pathString, "/", 1, true) then
		pathString = pathString:gsub("%.", "/")
	end

	-- Trim leading/trailing slash
	pathString = pathString:gsub("^/", ""):gsub("/$", "")

	return pathString
end

local function splitPath(pathString)
	pathString = normalizePath(pathString)
	if pathString == "" then
		return {}
	end
	return string.split(pathString, "/")
end

local function getServiceSafe(name)
	local ok, svc = pcall(function()
		return game:GetService(name)
	end)
	if ok and svc then return svc end
	return nil
end

local function getServiceCaseInsensitive(name)
	if typeof(name) ~= "string" then return nil, nil end

	-- workspace alias
	if name == "Workspace" or name == "workspace" then
		return workspace, "Workspace"
	end

	-- optional "game" root
	if ALLOW_GAME_ROOT and (name == "game" or name == "Game") then
		return game, "game"
	end

	-- case-insensitive allowlist match
	local matched = nil
	local lower = string.lower(name)
	for svcName, _ in pairs(ALLOWED_ROOTS) do
		if string.lower(svcName) == lower then
			matched = svcName
			break
		end
	end
	if not matched then
		return nil, nil
	end

	local svc = getServiceSafe(matched)
	if svc then
		return svc, matched
	end
	return nil, nil
end

-- Cache validity:
-- - Services are always valid
-- - Instances are valid if still in DataModel
local function isCachedValid(inst)
	if inst == nil then return false end
	if inst == game then return true end
	if typeof(inst.IsDescendantOf) == "function" then
		return inst:IsDescendantOf(game)
	end
	-- fallback
	return inst.Parent ~= nil
end

-- =========================
-- Public API
-- =========================
function Path.resolve(pathString)
	if typeof(pathString) ~= "string" then
		return nil, "Invalid path (not a string)"
	end

	local original = pathString
	pathString = trim(pathString)
	if pathString == "" then
		return nil, "Invalid path (empty)"
	end

	local norm = normalizePath(pathString)
	if norm == "" then
		return nil, "Invalid path (empty after normalize)"
	end

	-- Cache hit (normalized key)
	local cached = cacheGet(norm)
	if cached and isCachedValid(cached) then
		return cached, nil
	end

	local parts = splitPath(norm)
	if #parts == 0 then
		return nil, "Invalid path (empty after split)"
	end

	-- Root
	local rootInst, canonicalRoot = getServiceCaseInsensitive(parts[1])
	if not rootInst then
		return nil, string.format("Unknown or disallowed root '%s' (path='%s')", tostring(parts[1]), tostring(original))
	end

	local current = rootInst

	for i = 2, #parts do
		local seg = parts[i]
		if seg == "" then
			return nil, string.format("Invalid segment at index %d (path='%s')", i, tostring(original))
		end

		-- If current is game, next segment must be an allowed service
		if current == game then
			local svc = getServiceCaseInsensitive(seg)
			if svc then
				current = svc
				continue
			end
			return nil, string.format("Under 'game', '%s' is not an allowed service (path='%s')", seg, tostring(original))
		end

		local child = current:FindFirstChild(seg)
		if not child then
			return nil, string.format(
				"Missing '%s' under '%s' (at index %d, path='%s')",
				seg, current:GetFullName(), i, tostring(original)
			)
		end

		current = child
	end

	cachePut(norm, current)
	return current, nil
end

-- Optional: clear cache (useful after big refactors)
function Path.clearCache()
	cache = {}
	cacheOrder = {}
end

return Path


==========================================================================================
FILE: game/ReplicatedStorage/PersponifyStudioAI/Core/Transport
CLASS: ModuleScript
BYTES: 11654
SHA1: len=11654|a=37242|b=40104
------------------------------------------------------------------------------------------
-- Core/Transport.lua
local HttpService = game:GetService("HttpService")
local Config = require(script.Parent.Config)

local Transport = {}
Transport.__index = Transport

function Transport.new(log, conn)
	local self = setmetatable({
		log = log,
		conn = conn,

		clientId = HttpService:GenerateGUID(false),
		studioSessionId = HttpService:GenerateGUID(false),
		placeId = game.PlaceId or 0,

		leaseToken = nil,
		fence = nil,
		since = 0,

		_backoff = 0,

		caps = {
			endpoints = {
				health = "/health",
				register = "/register",
				sync = "/sync",
				wait = "/wait",
				receipt = "/receipt",
				heartbeat = "/heartbeat",

				scope_current = "/scope/current",
				context_export = "/context/export",
				context_latest = "/context/latest",
				context_summary = "/context/summary",
				context_reset = "/context/reset",
			},
			meta = {},
		},
	}, Transport)

	local ccaps = conn and conn.getCaps and conn:getCaps()
	if typeof(ccaps) == "table" and typeof(ccaps.endpoints) == "table" then
		for k, v in pairs(ccaps.endpoints) do
			if typeof(k) == "string" and typeof(v) == "string" and v ~= "" then
				self.caps.endpoints[k] = v
			end
		end
	end
	if typeof(ccaps) == "table" and typeof(ccaps.meta) == "table" then
		self.caps.meta = ccaps.meta
	end

	return self
end

function Transport:getSession()
	return {
		clientId = self.clientId,
		studioSessionId = self.studioSessionId,
		placeId = self.placeId,
		leaseToken = self.leaseToken,
		fence = self.fence,
		since = self.since,
	}
end

function Transport:getScope() return self.placeId, self.studioSessionId end
function Transport:getCaps() return self.caps end

local function clamp(n, lo, hi)
	if n < lo then return lo end
	if n > hi then return hi end
	return n
end

local function isArray(tbl)
	return typeof(tbl) == "table" and (tbl[1] ~= nil or next(tbl) == nil)
end

local function toList(v)
	if v == nil then return {} end
	if typeof(v) == "table" then
		if isArray(v) then return v end
		return { v }
	end
	return { v }
end

local function bumpSince(currentSince, seq)
	if typeof(seq) ~= "number" then
		return currentSince
	end
	local nextSince = seq + 1
	if nextSince > currentSince then
		return nextSince
	end
	return currentSince
end

local function joinUrl(base, path)
	base = tostring(base or "")
	path = tostring(path or "")
	if base == "" then return "" end
	if path == "" then return base end
	if string.sub(path, 1, 1) ~= "/" then
		path = "/" .. path
	end
	return base .. path
end

local function shortBody(body, limit)
	limit = limit or 220
	local s = tostring(body or "")
	if #s <= limit then return s end
	return string.sub(s, 1, limit) .. "…"
end

function Transport:_resetBackoff() self._backoff = 0 end
function Transport:_nextBackoff()
	local base = Config.ErrorBackoffSec or 1.0
	local maxB = Config.ErrorBackoffMaxSec or 8.0
	if self._backoff <= 0 then
		self._backoff = base
	else
		self._backoff = clamp(self._backoff * 2, base, maxB)
	end
	return self._backoff
end

local function clientTag()
	return tostring(Config.ClientTag or "PersponifyStudioAI/0.1.0")
end

local function diagEnabled(flagName)
	local d = Config.Diagnostics
	return typeof(d) == "table" and d[flagName] == true
end

-- IMPORTANT: HttpService:RequestAsync does NOT support a "Timeout" key.
local function http_request(method, url, bodyTable)
	local headers = { ["Content-Type"] = "application/json" }

	local req = {
		Url = url,
		Method = method,
		Headers = headers,
	}

	if bodyTable ~= nil then
		req.Body = HttpService:JSONEncode(bodyTable)
	end

	local ok, res = pcall(function()
		return HttpService:RequestAsync(req)
	end)

	if not ok then
		return false, "RequestAsync failed: " .. tostring(res), nil
	end

	local code = res.StatusCode or 0
	if code == 204 then
		return true, nil, 204
	end

	if not res.Success then
		return false, ("HTTP %d: %s"):format(code, shortBody(res.Body)), code
	end

	if res.Body == "" or res.Body == nil then
		return true, nil, code
	end

	local decodedOk, decoded = pcall(function()
		return HttpService:JSONDecode(res.Body)
	end)

	if decodedOk then
		return true, decoded, code
	end

	return true, res.Body, code
end

function Transport:_learnCapsFromHealth()
	local base = self.conn and self.conn.getBaseUrl and self.conn:getBaseUrl()
	if not base or base == "" then return end

	local url = joinUrl(base, self.caps.endpoints.health or "/health")
	local ok, data = http_request("GET", url, nil)
	if not ok or typeof(data) ~= "table" then return end

	if typeof(data.endpoints) == "table" then
		for k, v in pairs(data.endpoints) do
			if typeof(k) == "string" and typeof(v) == "string" and v ~= "" then
				self.caps.endpoints[k] = v
			end
		end
	end

	if typeof(data.meta) == "table" then
		self.caps.meta = data.meta
	end
end

function Transport:_recoverLease(reason)
	self.log:add(("[Transport] Recovering lease (%s)…"):format(tostring(reason)))
	self.leaseToken = nil
	self.fence = nil

	local ok, regErr = self:registerPrimary()
	if not ok then
		return false, regErr
	end
	local ok2, syncErr = self:sync()
	if not ok2 then
		return false, syncErr
	end
	return true, nil
end

function Transport:registerPrimary()
	local base = self.conn and self.conn.getBaseUrl and self.conn:getBaseUrl()
	if not base then return false, "NoBaseUrl" end

	self:_learnCapsFromHealth()

	local url = joinUrl(base, self.caps.endpoints.register or "/register")
	local ok, res, _code = http_request("POST", url, {
		clientId = self.clientId,
		studioSessionId = self.studioSessionId,
		placeId = self.placeId,
		clientTag = clientTag(),
	})

	if not ok then return false, res end
	if typeof(res) ~= "table" then return false, "Bad register response" end

	self.leaseToken = res.leaseToken
	self.fence = res.fence
	self.since = res.serverSeq or self.since
	self:_resetBackoff()

	if diagEnabled("EnableScopeLogs") then
		self.log:add(("[Transport] Registered. fence=%s since=%s"):format(tostring(self.fence), tostring(self.since)))
	end

	return true, res
end

function Transport:sync()
	local base = self.conn and self.conn.getBaseUrl and self.conn:getBaseUrl()
	if not base then return false, "NoBaseUrl" end
	if not self.leaseToken or not self.fence then return false, "NoLease" end

	self:_learnCapsFromHealth()

	local url = string.format(
		"%s%s?leaseToken=%s&fence=%s&placeId=%s&studioSessionId=%s",
		base,
		(self.caps.endpoints.sync or "/sync"),
		HttpService:UrlEncode(self.leaseToken),
		HttpService:UrlEncode(tostring(self.fence)),
		HttpService:UrlEncode(tostring(self.placeId)),
		HttpService:UrlEncode(self.studioSessionId)
	)

	local ok, res, code = http_request("GET", url, nil)
	if not ok then
		if code == 409 then
			return self:_recoverLease("sync 409")
		end
		return false, res
	end

	if typeof(res) == "table" then
		if self.conn and self.conn.setRulesVersion then
			self.conn:setRulesVersion(res.rulesVersion or "unknown")
		end
		if typeof(res.recommendedSince) == "number" and res.recommendedSince > self.since then
			self.since = res.recommendedSince
		end
	end

	self:_resetBackoff()
	return true, res
end

function Transport:waitForTransaction()
	local base = self.conn and self.conn.getBaseUrl and self.conn:getBaseUrl()
	if not base then return nil, "NoBaseUrl" end
	if not self.leaseToken or not self.fence then return nil, "NoLease" end

	self:_learnCapsFromHealth()

	local url = joinUrl(base, self.caps.endpoints.wait or "/wait")
	local timeoutSec = tonumber(Config.WaitLongPollSec) or 25

	local body = {
		leaseToken = self.leaseToken,
		fence = self.fence,
		since = self.since,
		placeId = self.placeId,
		studioSessionId = self.studioSessionId,
		clientTag = clientTag(),
		timeoutSec = timeoutSec,
	}

	if diagEnabled("EnableHttpTraces") then
		self.log:add(("[Transport] WAIT %s since=%s timeout=%ss"):format(url, tostring(self.since), tostring(timeoutSec)))
	end

	local ok, res, code = http_request("POST", url, body)

	if not ok then
		if code == 409 then
			local rok, rerr = self:_recoverLease("wait 409")
			if not rok then
				local backoff = self:_nextBackoff()
				return nil, tostring(rerr) .. (" (backoff %.1fs)"):format(backoff)
			end
			return nil, "Recovered"
		end

		local backoff = self:_nextBackoff()
		return nil, tostring(res) .. (" (backoff %.1fs)"):format(backoff)
	end

	if code == 204 or res == nil then
		self:_resetBackoff()
		return nil, "NoTx"
	end

	if typeof(res) ~= "table" then
		local backoff = self:_nextBackoff()
		return nil, "Bad wait response: " .. tostring(backoff)
	end

	if res.fence and self.fence and res.fence ~= self.fence then
		local rok, rerr = self:_recoverLease("FenceMismatch")
		if not rok then return nil, rerr end
		return nil, "Recovered"
	end

	self.since = bumpSince(self.since, res.seq)
	self:_resetBackoff()

	return { tx = res.tx, claimToken = res.claimToken, seq = res.seq, fence = res.fence }, nil
end

function Transport:postReceipt(receiptPayload, claimToken)
	local base = self.conn and self.conn.getBaseUrl and self.conn:getBaseUrl()
	if not base then return false, "NoBaseUrl" end
	if not self.leaseToken or not self.fence then return false, "NoLease" end

	self:_learnCapsFromHealth()

	local url = string.format(
		"%s%s?placeId=%s&studioSessionId=%s",
		base,
		(self.caps.endpoints.receipt or "/receipt"),
		HttpService:UrlEncode(tostring(self.placeId)),
		HttpService:UrlEncode(self.studioSessionId)
	)

	local body = {
		leaseToken = self.leaseToken,
		fence = self.fence,
		claimToken = claimToken,
		transactionId = receiptPayload.transactionId,

		applied = toList(receiptPayload.applied),
		errors = toList(receiptPayload.errors),
		notes = toList(receiptPayload.notes),

		meta = receiptPayload.meta,
		clientTag = clientTag(),
	}

	local ok, res, code = http_request("POST", url, body)
	if not ok then
		if code == 409 then
			local rok, rerr = self:_recoverLease("receipt 409")
			if not rok then return false, rerr end
			return false, "Recovered"
		end
		local backoff = self:_nextBackoff()
		return false, tostring(res) .. (" (backoff %.1fs)"):format(backoff)
	end

	self:_resetBackoff()
	return true, res
end

function Transport:heartbeat()
	local base = self.conn and self.conn.getBaseUrl and self.conn:getBaseUrl()
	if not base then return false, "NoBaseUrl" end
	if not self.leaseToken or not self.fence then return false, "NoLease" end

	self:_learnCapsFromHealth()

	local url = joinUrl(base, self.caps.endpoints.heartbeat or "/heartbeat")
	local ok, res, code = http_request("POST", url, {
		leaseToken = self.leaseToken,
		fence = self.fence,
		studioSessionId = self.studioSessionId,
		placeId = self.placeId,
		clientTag = clientTag(),
	})

	if not ok then
		if code == 409 then
			return self:_recoverLease("heartbeat 409")
		end
		local backoff = self:_nextBackoff()
		return false, tostring(res) .. (" (backoff %.1fs)"):format(backoff)
	end

	self:_resetBackoff()
	return true, res
end

function Transport:postContextExport(snapshot)
	local base = self.conn and self.conn.getBaseUrl and self.conn:getBaseUrl()
	if not base then return false, "NoBaseUrl" end
	if not self.leaseToken or not self.fence then return false, "NoLease" end

	self:_learnCapsFromHealth()

	local url = string.format(
		"%s%s?placeId=%s&studioSessionId=%s",
		base,
		(self.caps.endpoints.context_export or "/context/export"),
		HttpService:UrlEncode(tostring(self.placeId)),
		HttpService:UrlEncode(self.studioSessionId)
	)

	local ok, res, code = http_request("POST", url, snapshot)
	if not ok then
		if code == 409 then
			local rok, rerr = self:_recoverLease("context_export 409")
			if not rok then return false, rerr end
			return false, "Recovered"
		end
		return false, res
	end
	return true, res
end

return Transport


==========================================================================================
FILE: game/ReplicatedStorage/PersponifyStudioAI/Core/Version
CLASS: ModuleScript
BYTES: 778
SHA1: len=778|a=64505|b=20287
------------------------------------------------------------------------------------------
-- Core/Version.lua
local V = {
	-- Branding
	ProductName = "Persponify Studio AI",
	InternalRoot = "PersponifyStudioAI",

	-- Versions
	PluginVersion = "0.1.0",

	-- Protocol = transport/tool contract (register/wait/receipt fields, lease, fence, etc.)
	ProtocolVersion = 1,

	-- Schema = transaction/action payload layout (actions format, path conventions, etc.)
	SchemaVersion = 1,

	-- Build id: bump when you ship changes
	BuildId = "2025.12.21.1",

	-- Capability negotiation (future-safe)
	Capabilities = {
		"actionAliases",
		"dotAndSlashPaths",
		"receiptLists",
		"primaryFence",
		"sinceCursor",
	},
}

-- Roblox blocks setting User-Agent; we send this inside JSON bodies as clientTag.
V.ClientTag = string.format("%s/%s", V.InternalRoot, V.PluginVersion)

return V


==========================================================================================
FILE: game/ReplicatedStorage/PersponifyStudioAI/Main
CLASS: Script
BYTES: 15725
SHA1: len=15725|a=45136|b=1647
------------------------------------------------------------------------------------------
-- Main.lua (Fully upgraded, v0.1.0+)
-- Persponify Studio AI — Primary lease + long-poll + apply + receipt + context export.
-- Adds: manual mode, recovery-safe loops, jitter delays, better discover errors, safer previews.

local GuiService = game:GetService("GuiService")
local RunService = game:GetService("RunService")
local ChangeHistoryService = game:GetService("ChangeHistoryService")
local HttpService = game:GetService("HttpService")

local Config = require(script.Parent.Core.Config)
local Version = require(script.Parent.Core.Version)
local DebugLog = require(script.Parent.Core.DebugLog)
local Connection = require(script.Parent.Core.Connection)
local Transport = require(script.Parent.Core.Transport)
local Executor = require(script.Parent.Core.Executor)
local ContextExporter = require(script.Parent.Core.ContextExporter)

local Receipt = require(script.Parent.Protocol.Receipt)
local FastChecks = require(script.Parent.Validation.FastChecks)
local Transaction = require(script.Parent.Protocol.Transaction) -- if you have it (safe)
local Widget = require(script.Parent.UI.Widget)

-- IMPORTANT: bump each paste
local BUILD_ID = "BUILD-2025-12-22-MAIN-FULL-1"

-- ----------------------------
-- Init
-- ----------------------------
local log = DebugLog.new(Config.LogBufferLines or 2000)
local slog = log:scope("Main")

local conn = Connection.new(log)
local transport = Transport.new(log, conn)
local executor = Executor.new(log)
local exporter = ContextExporter.new(log)

local ui = Widget.build(plugin, Version.ProductName)

local autoEnabled = true
local logsEnabled = true
local runToken = 0
local active = false

-- Last fetched tx for manual preview/apply
local lastFetched = nil -- { tx=table, claimToken=string?, seq=number? }

-- Context export throttling
local contextDirty = false
local lastContextExportAt = 0
local CONTEXT_EXPORT_MIN_INTERVAL = (Config.ContextExportMinIntervalSec or 12)

-- UI log pump caching
local lastLogText = ""

-- ----------------------------
-- Small helpers
-- ----------------------------
local function noTxDelay()
	if typeof(Config.getNoTxDelay) == "function" then
		return Config.getNoTxDelay()
	end
	return Config.WaitNoTxDelaySec or 0.35
end

local function heartbeatDelay()
	if typeof(Config.getHeartbeatDelay) == "function" then
		return Config.getHeartbeatDelay()
	end
	return Config.HeartbeatIntervalSec or 5
end

local function isConnected()
	return conn:getBaseUrl() ~= nil
end

local function tryOpenBrowser(url)
	local gui = GuiService
	if gui and typeof(gui.OpenBrowserWindow) == "function" then
		local ok = pcall(function()
			gui:OpenBrowserWindow(url)
		end)
		return ok
	end
	return false
end

local function safeStr(v)
	if v == nil then return "nil" end
	return tostring(v)
end

local function shortText(s, limit)
	limit = limit or (Config.MaxPreviewChars or 120000)
	s = tostring(s or "")
	if #s <= limit then return s end
	return s:sub(1, limit) .. "\n…(truncated)…"
end

local function prettyTx(tx)
	-- Roblox has no built-in pretty JSON. Keep it readable:
	local ok, encoded = pcall(function()
		return HttpService:JSONEncode(tx)
	end)
	if ok then
		return encoded
	end
	return tostring(tx)
end

-- ----------------------------
-- UI updates
-- ----------------------------
local function pushLogToUI(force)
	if not ui or not ui.logText or not ui.logFrame then return end
	if not logsEnabled then return end

	local t = log:getText()
	if not force and t == lastLogText then
		return
	end
	lastLogText = t
	ui.logText.Text = t

	-- Scroll to bottom
	task.defer(function()
		if not ui or not ui.logFrame then return end
		local frame = ui.logFrame
		local canvasY = frame.AbsoluteCanvasSize.Y
		local viewY = frame.AbsoluteSize.Y
		local maxY = math.max(0, canvasY - viewY)
		frame.CanvasPosition = Vector2.new(0, maxY)
	end)
end

local function refreshUI()
	if not ui then return end

	local base = conn:getBaseUrl()
	local session = transport:getSession()

	if base and active then
		ui.statusBtn.Text = "Status: Primary"
		ui.statusBtn.BackgroundColor3 = Color3.fromRGB(80, 255, 120)
		ui.statusBtn.TextColor3 = Color3.fromRGB(10, 10, 10)
		ui.btnConnect.Text = "Disconnect"
		ui.rules.Text = ("Rules: %s | %s | fence=%s since=%s"):format(
			tostring(conn:getRulesVersion()),
			BUILD_ID,
			tostring(session.fence),
			tostring(session.since)
		)
		ui.urlBox.Text = base
	elseif base and not active then
		ui.statusBtn.Text = "Status: Connected (inactive)"
		ui.statusBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
		ui.statusBtn.TextColor3 = Color3.fromRGB(225, 255, 225)
		ui.btnConnect.Text = "Reconnect"
		ui.rules.Text = ("Rules: %s | %s"):format(tostring(conn:getRulesVersion()), BUILD_ID)
		ui.urlBox.Text = base
	else
		ui.statusBtn.Text = "Status: Disconnected"
		ui.statusBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
		ui.statusBtn.TextColor3 = Color3.fromRGB(225, 255, 225)
		ui.btnConnect.Text = "Connect"
		ui.rules.Text = "Rules: unknown | " .. BUILD_ID
		ui.urlBox.Text = ""
	end

	ui.setAutoUI(autoEnabled)
	ui.setLogsUI(logsEnabled)

	-- Manual buttons visible only when Auto OFF
	ui.setManualVisible(not autoEnabled)

	ui.help.Text =
		autoEnabled
		and "Auto = primary lease + wait + apply + receipt + context export (pre/post)."
		or "Manual = Fetch → Preview → Apply (Auto is OFF)."
end

local function logLine(msg, level)
	level = tostring(level or "INFO")
	slog:add({ level = level, msg = tostring(msg) })
	print("[PersponifyStudioAI]", tostring(msg))
	refreshUI()
	pushLogToUI(true)
end

local function freezeSecondary(reason)
	active = false
	runToken += 1
	logLine("PRIMARY LOST → now inactive. Reason: " .. tostring(reason), "WARN")
end

local function disconnect()
	active = false
	runToken += 1
	conn:disconnect()
	lastFetched = nil
	logLine("Disconnected.", "INFO")
end

local function SAFE(label, fn)
	local ok, a, b = pcall(fn)
	if not ok then
		logLine("!! ERROR in " .. label .. ": " .. tostring(a), "ERROR")
		return nil, "pcall_error"
	end
	return a, b
end

-- ----------------------------
-- Context export
-- ----------------------------
local function markContextDirty()
	contextDirty = true
end

local function tryExportContext(reason)
	if not isConnected() or not active then return end

	local now = os.clock()
	if (now - lastContextExportAt) < CONTEXT_EXPORT_MIN_INTERVAL then
		return
	end

	lastContextExportAt = now
	contextDirty = false

	local placeId, studioSessionId = transport:getScope()
	logLine(("Context export (%s)… scope placeId=%s session=%s"):format(
		tostring(reason),
		tostring(placeId),
		tostring(studioSessionId)
		), "DEBUG")

	local snap = exporter:buildSnapshot("default", {
		buildId = BUILD_ID,
		rulesVersion = conn:getRulesVersion(),
		reason = tostring(reason),
	})

	local ok, res = transport:postContextExport(snap)
	if ok then
		if typeof(res) == "table" then
			logLine(("Context export OK. tree=%s scripts=%s"):format(
				tostring(res.treeCount or "?"),
				tostring(res.scriptCount or "?")
				), "INFO")
		else
			logLine("Context export OK.", "INFO")
		end
	else
		-- Not fatal
		logLine("Context export failed (non-fatal): " .. tostring(res), "WARN")
	end
end

-- ----------------------------
-- Apply pipeline
-- ----------------------------
local function applyTransaction(tx, claimToken)
	if not tx then
		logLine("Apply: no tx", "WARN")
		return
	end

	local txId = tostring(tx.transactionId or tx.id or "")
	logLine("Apply start: " .. txId, "INFO")

	local notes = SAFE("FastChecks.run", function()
		return FastChecks.run(tx)
	end) or {}

	local okPre, preErr = SAFE("executor:preflight", function()
		return executor:preflight(tx)
	end)

	if not okPre then
		logLine("Preflight failed: " .. tostring(preErr), "ERROR")
		local receipt = Receipt.build(txId, {}, { tostring(preErr) }, notes)
		local okR, errR = transport:postReceipt(receipt, claimToken)
		if not okR and errR ~= "Recovered" then
			freezeSecondary(errR)
		end
		return
	end

	local applied, errors = SAFE("executor:apply", function()
		return executor:apply(tx)
	end)
	applied = applied or {}
	errors = errors or {}

	local receipt = Receipt.build(txId, applied, errors, notes)
	local okR, errR = transport:postReceipt(receipt, claimToken)
	if not okR then
		-- IMPORTANT: "Recovered" means transport re-registered; do NOT freeze.
		if errR == "Recovered" then
			logLine("Receipt recovered; continuing.", "WARN")
		else
			freezeSecondary(errR)
			return
		end
	end

	logLine("Apply end: " .. txId, "INFO")

	-- Mark dirty for post-apply export
	markContextDirty()
end

-- ----------------------------
-- Manual mode helpers
-- ----------------------------
local function fetchOnceAsync()
	task.spawn(function()
		if not isConnected() or not active then
			logLine("Fetch: not primary/connected", "WARN")
			return
		end
		logLine("Fetch: waiting once…", "INFO")

		local waitRes, err = transport:waitForTransaction()

		-- NoTx
		if err == "NoTx" then
			logLine("Fetch: NoTx", "DEBUG")
			return
		end

		-- Recovered: keep going
		if err == "Recovered" then
			logLine("Fetch: recovered lease; try again.", "WARN")
			return
		end

		if err then
			logLine("Fetch failed: " .. tostring(err), "ERROR")
			return
		end

		if waitRes and waitRes.tx then
			lastFetched = waitRes
			local summary = (Transaction and Transaction.summarize and Transaction.summarize(waitRes.tx))
				or ("txId=" .. tostring(waitRes.tx.transactionId or waitRes.tx.id or "?"))
			logLine("Fetched: " .. summary, "INFO")
			ui.setPreview(shortText(prettyTx(waitRes.tx)))
		else
			logLine("Fetch: nothing returned", "WARN")
		end
	end)
end

local function previewLast()
	if not lastFetched or not lastFetched.tx then
		ui.setPreview("No fetched transaction yet.\n\nManual mode:\n1) Fetch\n2) Preview\n3) Apply")
		return
	end
	ui.setPreview(shortText(prettyTx(lastFetched.tx)))
end

local function applyLastAsync()
	task.spawn(function()
		if not lastFetched or not lastFetched.tx then
			logLine("Apply: nothing fetched yet", "WARN")
			return
		end
		applyTransaction(lastFetched.tx, lastFetched.claimToken)
		-- Export after apply (throttled)
		if contextDirty then
			tryExportContext("post-apply-manual")
		end
	end)
end

local function undoOnce()
	local ok, err = pcall(function()
		ChangeHistoryService:Undo()
	end)
	if ok then
		logLine("Undo executed.", "INFO")
		markContextDirty()
	else
		logLine("Undo failed: " .. tostring(err), "ERROR")
	end
end

-- ----------------------------
-- Loops
-- ----------------------------
local function startHeartbeatLoop(myToken)
	task.spawn(function()
		while myToken == runToken do
			if not isConnected() or not active then
				task.wait(0.5)
			else
				local ok, err = transport:heartbeat()
				if not ok then
					-- "Recovered" means transport fixed itself; don't freeze
					if err == "Recovered" then
						logLine("Heartbeat recovered; continuing.", "WARN")
					else
						freezeSecondary(err)
						break
					end
				end
				task.wait(heartbeatDelay())
			end
		end
	end)
end

local function startAutoLoop(myToken)
	task.spawn(function()
		logLine("Auto loop started.", "INFO")
		while myToken == runToken do
			if not isConnected() or not active or not autoEnabled then
				task.wait(0.25)
				continue
			end

			local waitRes, err = transport:waitForTransaction()
			if myToken ~= runToken then break end

			if err == "NoTx" then
				task.wait(noTxDelay())
				if contextDirty then
					tryExportContext("scheduled-post-apply")
				end
				continue
			end

			-- IMPORTANT FIX: do not freeze on internal lease recovery
			if err == "Recovered" then
				task.wait(noTxDelay())
				continue
			end

			if err then
				freezeSecondary(err)
				break
			end

			if waitRes and waitRes.tx then
				lastFetched = waitRes
				logLine("Fetched tx seq=" .. tostring(waitRes.seq) .. " claim=" .. tostring(waitRes.claimToken), "INFO")
				logLine("Fetched txId=" .. tostring(waitRes.tx.transactionId or waitRes.tx.id or ""), "DEBUG")

				applyTransaction(waitRes.tx, waitRes.claimToken)

				if contextDirty then
					tryExportContext("post-apply-auto")
				end
			else
				task.wait(noTxDelay())
			end
		end
	end)
end

local function connectPrimary()
	logLine("Discovering local dashboard…", "INFO")

	local okDiscover, why = conn:discover()
	if not okDiscover then
		logLine("Discover failed:\n" .. tostring(why), "ERROR")
		return
	end

	logLine("Registering primary lease…", "INFO")
	local okReg, regRes = transport:registerPrimary()
	if not okReg then
		logLine("Register failed: " .. tostring(regRes), "ERROR")
		return
	end

	logLine(("Primary OK. fence=%s serverSeq=%s"):format(tostring(regRes.fence), tostring(regRes.serverSeq)), "INFO")

	logLine("Sync…", "INFO")
	local okSync, syncRes = transport:sync()
	if not okSync then
		logLine("Sync failed: " .. tostring(syncRes), "ERROR")
		return
	end

	active = true
	runToken += 1
	local myToken = runToken

	local placeId, studioSessionId = transport:getScope()
	logLine(("SCOPE placeId=%s studioSessionId=%s"):format(tostring(placeId), tostring(studioSessionId)), "INFO")
	logLine("Rules handshake OK — version=" .. tostring(conn:getRulesVersion()), "INFO")

	-- Pre-context export once we are primary + synced
	markContextDirty()
	tryExportContext("on-connect")

	startHeartbeatLoop(myToken)
	startAutoLoop(myToken)
end

-- ----------------------------
-- UI wiring
-- ----------------------------
ui.btnConnect.MouseButton1Click:Connect(function()
	logLine("=== CONNECT CLICKED ===", "DEBUG")
	if isConnected() then
		disconnect()
	else
		connectPrimary()
	end
end)

ui.btnOpenDash.MouseButton1Click:Connect(function()
	logLine("=== OPEN CLICKED ===", "DEBUG")
	local base = conn:getBaseUrl()
	if not base then
		logLine("Open: not connected", "WARN")
		return
	end

	-- open a simple endpoint that always exists
	local url = base .. "/health"
	local opened = tryOpenBrowser(url)
	if opened then
		logLine("Opened: " .. url, "INFO")
	else
		logLine("Open blocked — copy URL then paste into browser.", "WARN")
	end
end)

ui.btnAuto.MouseButton1Click:Connect(function()
	autoEnabled = not autoEnabled
	logLine("Auto toggled: " .. tostring(autoEnabled), "INFO")
	refreshUI()
end)

ui.btnLogs.MouseButton1Click:Connect(function()
	logsEnabled = not logsEnabled
	logLine("Logs toggled: " .. tostring(logsEnabled), "INFO")
	refreshUI()
	pushLogToUI(true)
end)

-- Manual buttons (only meaningful when Auto OFF)
if ui.btnFetch then
	ui.btnFetch.MouseButton1Click:Connect(function()
		logLine("=== FETCH CLICKED ===", "DEBUG")
		fetchOnceAsync()
	end)
end

if ui.btnPreview then
	ui.btnPreview.MouseButton1Click:Connect(function()
		logLine("=== PREVIEW CLICKED ===", "DEBUG")
		previewLast()
	end)
end

if ui.btnApply then
	ui.btnApply.MouseButton1Click:Connect(function()
		logLine("=== APPLY CLICKED ===", "DEBUG")
		applyLastAsync()
	end)
end

if ui.btnUndoHint then
	ui.btnUndoHint.MouseButton1Click:Connect(function()
		logLine("=== UNDO CLICKED ===", "DEBUG")
		undoOnce()
	end)
end

ui.btnSelectUrl.MouseButton1Click:Connect(function()
	logLine("=== SELECT URL CLICKED ===", "DEBUG")
	ui.urlBox:CaptureFocus()
	ui.urlBox.CursorPosition = 1
	ui.urlBox.SelectionStart = #ui.urlBox.Text + 1
	logLine("URL selected — Cmd+C / Ctrl+C to copy.", "INFO")
end)

-- Boot
logLine(("%s loaded (v%s, protocol v%d)"):format(
	Version.ProductName,
	Version.PluginVersion,
	Version.ProtocolVersion
	), "INFO")

logLine("BOOT BUILD_ID = " .. BUILD_ID, "INFO")
refreshUI()
pushLogToUI(true)

RunService.Heartbeat:Connect(function()
	if ui and ui.dock and ui.dock.Enabled and logsEnabled then
		pushLogToUI(false)
	end

	-- Scheduled context export (if dirty + enough time passed)
	if contextDirty and isConnected() and active then
		tryExportContext("scheduled")
	end
end)


==========================================================================================
FILE: game/ReplicatedStorage/PersponifyStudioAI/Protocol/Receipt
CLASS: ModuleScript
BYTES: 1793
SHA1: len=1793|a=16863|b=44374
------------------------------------------------------------------------------------------
-- Protocol/Receipt.lua
-- v1-compatible, vNext-ready receipt builder
-- Fixes: empty-array detection, stable shapes, safe normalization.

local Receipt = {}

-- Treat {} as a valid array (empty list), not a dict.
local function isArray(t)
	if typeof(t) ~= "table" then return false end
	-- If table is empty, consider it an array.
	if next(t) == nil then return true end
	-- If it has [1], it's an array.
	if t[1] ~= nil then return true end
	return false
end

local function toList(v)
	if v == nil then
		return {}
	end

	if typeof(v) == "table" then
		if isArray(v) then
			return v
		end
		-- dict-like table -> wrap as single element
		return { v }
	end

	-- number/string/bool/etc -> wrap
	return { v }
end

local function safeStr(v)
	if v == nil then return "" end
	return tostring(v)
end

local function normalizeMeta(meta)
	if typeof(meta) ~= "table" then return nil end

	-- Keep meta small + JSON-friendly. (Server can ignore fields it doesn't use.)
	local out = {}
	for k, v in pairs(meta) do
		if typeof(k) == "string" then
			local tv = typeof(v)
			if tv == "string" or tv == "number" or tv == "boolean" or tv == "table" then
				out[k] = v
			else
				out[k] = tostring(v)
			end
		end
	end

	-- Add a local timestamp if not provided (nice for debugging)
	if out.clientTime == nil then
		out.clientTime = os.time()
	end

	return out
end

-- Receipt.build(txId, applied, errors, notes, meta?)
function Receipt.build(transactionId, applied, errors, notes, meta)
	local txId = safeStr(transactionId)
	if txId == "" then
		txId = "unknown"
	end

	return {
		transactionId = txId,

		-- Always arrays for server safety
		applied = toList(applied),
		errors  = toList(errors),
		notes   = toList(notes),

		-- Future-safe extras
		meta = normalizeMeta(meta),
	}
end

return Receipt


==========================================================================================
FILE: game/ReplicatedStorage/PersponifyStudioAI/Protocol/Transaction
CLASS: ModuleScript
BYTES: 3089
SHA1: len=3089|a=41168|b=2419
------------------------------------------------------------------------------------------
-- Protocol/Transaction.lua
-- v1-compatible, vNext-ready transaction helpers.
-- Upgrades:
--  - robust array detection (empty array ok)
--  - safer action extraction (plan nesting supported)
--  - clearer summaries
--  - optional shape validation stays non-throwing

local Transaction = {}

local function safeStr(v)
	if v == nil then return "nil" end
	return tostring(v)
end

local function getActions(tx)
	if typeof(tx) ~= "table" then return nil end
	if typeof(tx.actions) == "table" then return tx.actions end
	-- Future-safe: planning mode might nest actions
	if typeof(tx.plan) == "table" and typeof(tx.plan.actions) == "table" then
		return tx.plan.actions
	end
	return nil
end

-- Treat {} as valid empty array; treat tables with [1] as arrays.
-- Everything else (dict-like) is not an array.
local function isArray(t)
	if typeof(t) ~= "table" then return false end
	if next(t) == nil then return true end
	if t[1] ~= nil then return true end
	return false
end

local function countTable(t)
	if typeof(t) ~= "table" then return 0 end
	local n = 0
	for _ in pairs(t) do n += 1 end
	return n
end

function Transaction.summarize(tx)
	if typeof(tx) ~= "table" then
		return "(no tx)"
	end

	local id = safeStr(tx.transactionId or tx.id or "unknown")
	local actions = getActions(tx)

	local n = 0
	if actions then
		n = isArray(actions) and #actions or countTable(actions)
	end

	-- Include first few action types for fast debugging (array-first)
	local types = {}
	if actions and isArray(actions) then
		local limit = math.min(#actions, 4)
		for i = 1, limit do
			local a = actions[i]
			local t = (typeof(a) == "table" and typeof(a.type) == "string") and a.type or "?"
			table.insert(types, t)
		end
	end

	local typeSuffix = ""
	if #types > 0 then
		typeSuffix = " [" .. table.concat(types, ", ") .. (n > #types and ", …" or "") .. "]"
	end

	-- Optional: show mode if present (future-proof)
	local mode = nil
	if typeof(tx.mode) == "string" and tx.mode ~= "" then
		mode = tx.mode
	elseif typeof(tx.plan) == "table" and typeof(tx.plan.mode) == "string" and tx.plan.mode ~= "" then
		mode = tx.plan.mode
	end
	if mode then
		return string.format("%s (%s, %d actions)%s", id, mode, n, typeSuffix)
	end

	return string.format("%s (%d actions)%s", id, n, typeSuffix)
end

-- Optional helper: non-throwing shape validation
-- Returns: true,nil OR false,"reason"
function Transaction.validateShape(tx)
	if typeof(tx) ~= "table" then
		return false, "tx not a table"
	end

	if tx.protocolVersion ~= nil and typeof(tx.protocolVersion) ~= "number" then
		return false, "protocolVersion must be number"
	end

	local actions = getActions(tx)
	if actions == nil then
		return false, "missing actions"
	end

	if not isArray(actions) then
		return false, "actions must be an array (list)"
	end

	for i, a in ipairs(actions) do
		if typeof(a) ~= "table" then
			return false, ("action[%d] must be table"):format(i)
		end
		if typeof(a.type) ~= "string" or a.type == "" then
			return false, ("action[%d].type must be string"):format(i)
		end
	end

	return true, nil
end

return Transaction


==========================================================================================
FILE: game/ReplicatedStorage/PersponifyStudioAI/UI/Widget
CLASS: ModuleScript
BYTES: 19600
SHA1: len=19600|a=44297|b=22946
------------------------------------------------------------------------------------------
-- Core/Widget.lua
-- UX-upgraded: rounded corners, strokes, hover/press feedback, persistent settings.
-- Backwards compatible return table (Main can keep using the same fields).

local TweenService = game:GetService("TweenService")

local Widget = {}

local SETTINGS_KEY = "PersponifyStudioAI_WidgetSettings_v1"

local function safeStr(v)
	if v == nil then return "" end
	return tostring(v)
end

local function clamp(n, lo, hi)
	if n < lo then return lo end
	if n > hi then return hi end
	return n
end

local function readSettings(plugin)
	local ok, s = pcall(function()
		return plugin:GetSetting(SETTINGS_KEY)
	end)
	if ok and typeof(s) == "table" then
		return s
	end
	return {}
end

local function writeSettings(plugin, tbl)
	pcall(function()
		plugin:SetSetting(SETTINGS_KEY, tbl)
	end)
end

local function addCorner(inst, px)
	local c = Instance.new("UICorner")
	c.CornerRadius = UDim.new(0, px or 8)
	c.Parent = inst
	return c
end

local function addStroke(inst, thickness, color, transparency)
	local s = Instance.new("UIStroke")
	s.Thickness = thickness or 1
	s.Color = color
	s.Transparency = transparency or 0
	s.Parent = inst
	return s
end

local function tweenBg(guiObj, toColor, t)
	t = t or 0.08
	if not guiObj or not guiObj:IsA("GuiObject") then return end
	local ok = pcall(function()
		TweenService:Create(guiObj, TweenInfo.new(t, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
			BackgroundColor3 = toColor,
		}):Play()
	end)
end

local function wireButtonFeedback(btn, colors)
	-- colors = { normal=Color3, hover=Color3, down=Color3, disabled=Color3? }
	if not btn or not btn:IsA("TextButton") then return end

	local normal = colors.normal
	local hover = colors.hover or normal
	local down = colors.down or hover

	btn.AutoButtonColor = false

	btn.MouseEnter:Connect(function()
		if btn.Active and btn.BackgroundTransparency < 1 then
			tweenBg(btn, hover)
		end
	end)

	btn.MouseLeave:Connect(function()
		if btn.Active and btn.BackgroundTransparency < 1 then
			tweenBg(btn, normal)
		end
	end)

	btn.MouseButton1Down:Connect(function()
		if btn.Active and btn.BackgroundTransparency < 1 then
			tweenBg(btn, down, 0.05)
		end
	end)

	btn.MouseButton1Up:Connect(function()
		if btn.Active and btn.BackgroundTransparency < 1 then
			tweenBg(btn, hover, 0.06)
		end
	end)
end

function Widget.build(plugin, productName)
	productName = productName or "Persponify Studio AI"

	-- Theme (green/black)
	local BG = Color3.fromRGB(12, 14, 12)
	local PANEL = Color3.fromRGB(18, 22, 18)
	local OUTLINE = Color3.fromRGB(40, 70, 40)
	local TEXT = Color3.fromRGB(225, 255, 225)
	local MUTED = Color3.fromRGB(160, 190, 160)
	local GREEN = Color3.fromRGB(80, 255, 120)
	local GRAYBTN = Color3.fromRGB(60, 60, 60)
	local GRAYHOVER = Color3.fromRGB(72, 72, 72)
	local GRAYDOWN = Color3.fromRGB(48, 48, 48)
	local RED = Color3.fromRGB(255, 110, 110)
	local YELLOW = Color3.fromRGB(255, 210, 90)

	-- Load persisted UI prefs
	local settings = readSettings(plugin)
	local autoOn = (settings.autoOn ~= false) -- default true
	local logsOn = (settings.logsOn ~= false) -- default true

	-- Toolbar
	local toolbar = plugin:CreateToolbar("Persponify")
	local openBtn = toolbar:CreateButton("Studio AI", "Open " .. productName, "")

	-- Dock widget
	local widgetInfo = DockWidgetPluginGuiInfo.new(
		Enum.InitialDockState.Left,
		false,  -- initial enabled; we'll override with saved state below
		false,
		460, 460,
		340, 260
	)

	local createFn = plugin.CreateDockWidgetPluginGuiAsync or plugin.CreateDockWidgetPluginGui
	local dock = createFn(plugin, "PersponifyStudioAI_Widget", widgetInfo)
	dock.Title = productName
	dock.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

	-- Restore dock enabled state
	if typeof(settings.dockEnabled) == "boolean" then
		dock.Enabled = settings.dockEnabled
	end

	-- Root scroll (vertical only)
	local root = Instance.new("ScrollingFrame")
	root.Parent = dock
	root.Size = UDim2.new(1, 0, 1, 0)
	root.BackgroundColor3 = BG
	root.BorderSizePixel = 0
	root.ScrollBarThickness = 8
	root.ScrollingDirection = Enum.ScrollingDirection.Y
	root.ScrollingEnabled = true
	root.AutomaticCanvasSize = Enum.AutomaticSize.Y
	root.CanvasSize = UDim2.new(0, 0, 0, 0)

	local content = Instance.new("Frame")
	content.Parent = root
	content.BackgroundTransparency = 1
	content.Size = UDim2.new(1, 0, 0, 0)
	content.AutomaticSize = Enum.AutomaticSize.Y

	local pad = Instance.new("UIPadding")
	pad.Parent = content
	pad.PaddingLeft = UDim.new(0, 10)
	pad.PaddingRight = UDim.new(0, 10)
	pad.PaddingTop = UDim.new(0, 10)
	pad.PaddingBottom = UDim.new(0, 10)

	local list = Instance.new("UIListLayout")
	list.Parent = content
	list.FillDirection = Enum.FillDirection.Vertical
	list.SortOrder = Enum.SortOrder.LayoutOrder
	list.Padding = UDim.new(0, 8)

	-- Helpers
	local function label(txt, size, color, bold)
		local l = Instance.new("TextLabel")
		l.BackgroundTransparency = 1
		l.Size = UDim2.new(1, 0, 0, size + 8)
		l.Font = bold and Enum.Font.SourceSansBold or Enum.Font.SourceSans
		l.TextSize = size
		l.TextColor3 = color or TEXT
		l.TextXAlignment = Enum.TextXAlignment.Left
		l.TextYAlignment = Enum.TextYAlignment.Center
		l.TextWrapped = true
		l.Text = txt
		return l
	end

	local function button(txt, bg, textColor)
		local b = Instance.new("TextButton")
		b.Size = UDim2.new(1, 0, 0, 36)
		b.BackgroundColor3 = bg
		b.BorderSizePixel = 0
		b.Font = Enum.Font.SourceSansBold
		b.TextSize = 16
		b.TextColor3 = textColor or TEXT
		b.Text = txt
		addCorner(b, 10)
		return b
	end

	local function smallButton(txt, bg, textColor)
		local b = Instance.new("TextButton")
		b.Size = UDim2.new(1, 0, 1, 0)
		b.BackgroundColor3 = bg
		b.BorderSizePixel = 0
		b.Font = Enum.Font.SourceSansBold
		b.TextSize = 14
		b.TextColor3 = textColor or TEXT
		b.Text = txt
		addCorner(b, 10)
		return b
	end

	local function panelFrame(height)
		local f = Instance.new("Frame")
		f.Size = UDim2.new(1, 0, 0, height)
		f.BackgroundColor3 = PANEL
		f.BorderSizePixel = 0
		addCorner(f, 12)
		addStroke(f, 1, OUTLINE, 0)
		return f
	end

	-- =========================
	-- Header
	-- =========================
	local header = Instance.new("Frame")
	header.BackgroundTransparency = 1
	header.Size = UDim2.new(1, 0, 0, 44)
	header.LayoutOrder = 1
	header.Parent = content

	local hList = Instance.new("UIListLayout")
	hList.Parent = header
	hList.FillDirection = Enum.FillDirection.Horizontal
	hList.SortOrder = Enum.SortOrder.LayoutOrder
	hList.Padding = UDim.new(0, 10)
	hList.VerticalAlignment = Enum.VerticalAlignment.Center

	local dot = Instance.new("Frame")
	dot.LayoutOrder = 1
	dot.Parent = header
	dot.Size = UDim2.new(0, 16, 0, 16)
	dot.BackgroundColor3 = GRAYBTN
	dot.BorderSizePixel = 0
	addCorner(dot, 99)
	addStroke(dot, 1, OUTLINE, 0.2)

	local versionModule = require(script.Parent.Parent.Core.Version)
	local vLabel = label("v" .. tostring(versionModule.PluginVersion), 16, TEXT, true)
	vLabel.LayoutOrder = 2
	vLabel.Parent = header
	vLabel.Size = UDim2.new(1, -40, 1, 0)

	-- =========================
	-- Connection row
	-- =========================
	local connRow = Instance.new("Frame")
	connRow.BackgroundTransparency = 1
	connRow.Size = UDim2.new(1, 0, 0, 40)
	connRow.LayoutOrder = 2
	connRow.Parent = content

	local connGrid = Instance.new("UIGridLayout")
	connGrid.Parent = connRow
	connGrid.FillDirection = Enum.FillDirection.Horizontal
	connGrid.SortOrder = Enum.SortOrder.LayoutOrder
	connGrid.CellPadding = UDim2.new(0, 10, 0, 0)
	connGrid.CellSize = UDim2.new(0.333, -8, 1, 0)

	local btnConnect = button("Connect", GREEN, Color3.fromRGB(10, 10, 10))
	btnConnect.Parent = connRow
	wireButtonFeedback(btnConnect, { normal = GREEN, hover = Color3.fromRGB(95, 255, 135), down = Color3.fromRGB(60, 220, 100) })

	local btnOpenDash = button("Open", GRAYBTN, TEXT)
	btnOpenDash.Parent = connRow
	wireButtonFeedback(btnOpenDash, { normal = GRAYBTN, hover = GRAYHOVER, down = GRAYDOWN })

	local statusBtn = button("Status: Disconnected", GRAYBTN, TEXT)
	statusBtn.Parent = connRow
	wireButtonFeedback(statusBtn, { normal = GRAYBTN, hover = GRAYHOVER, down = GRAYDOWN })

	local rules = label("Rules: unknown", 13, MUTED, false)
	rules.LayoutOrder = 3
	rules.Parent = content

	-- =========================
	-- Toggles row (Auto + Logs)
	-- =========================
	local togglesRow = Instance.new("Frame")
	togglesRow.BackgroundTransparency = 1
	togglesRow.Size = UDim2.new(1, 0, 0, 32)
	togglesRow.LayoutOrder = 4
	togglesRow.Parent = content

	local toggleGrid = Instance.new("UIGridLayout")
	toggleGrid.Parent = togglesRow
	toggleGrid.FillDirection = Enum.FillDirection.Horizontal
	toggleGrid.SortOrder = Enum.SortOrder.LayoutOrder
	toggleGrid.CellPadding = UDim2.new(0, 10, 0, 0)
	toggleGrid.CellSize = UDim2.new(0.5, -5, 1, 0)

	local btnAuto = smallButton("Auto: ON", GREEN, Color3.fromRGB(10, 10, 10))
	btnAuto.Parent = togglesRow
	wireButtonFeedback(btnAuto, { normal = GREEN, hover = Color3.fromRGB(95, 255, 135), down = Color3.fromRGB(60, 220, 100) })

	local btnLogs = smallButton("Logs: ON", GRAYBTN, TEXT)
	btnLogs.Parent = togglesRow
	wireButtonFeedback(btnLogs, { normal = GRAYBTN, hover = GRAYHOVER, down = GRAYDOWN })

	local help = label("Auto runs everything. If Auto isn’t working, turn it OFF to show manual buttons.", 13, MUTED, false)
	help.LayoutOrder = 5
	help.Parent = content

	-- =========================
	-- Manual row (hidden when Auto ON)
	-- =========================
	local manualRow = Instance.new("Frame")
	manualRow.BackgroundTransparency = 1
	manualRow.Size = UDim2.new(1, 0, 0, 32)
	manualRow.LayoutOrder = 6
	manualRow.Parent = content

	local manualGrid = Instance.new("UIGridLayout")
	manualGrid.Parent = manualRow
	manualGrid.FillDirection = Enum.FillDirection.Horizontal
	manualGrid.SortOrder = Enum.SortOrder.LayoutOrder
	manualGrid.CellPadding = UDim2.new(0, 10, 0, 0)
	manualGrid.CellSize = UDim2.new(0.25, -8, 1, 0)

	local btnFetch = smallButton("Fetch", GREEN, Color3.fromRGB(10, 10, 10)); btnFetch.Parent = manualRow
	local btnPreview = smallButton("Preview", GRAYBTN, TEXT); btnPreview.Parent = manualRow
	local btnApply = smallButton("Apply", GRAYBTN, TEXT); btnApply.Parent = manualRow
	local btnUndo = smallButton("Undo", GRAYBTN, TEXT); btnUndo.Parent = manualRow

	wireButtonFeedback(btnFetch, { normal = GREEN, hover = Color3.fromRGB(95, 255, 135), down = Color3.fromRGB(60, 220, 100) })
	wireButtonFeedback(btnPreview, { normal = GRAYBTN, hover = GRAYHOVER, down = GRAYDOWN })
	wireButtonFeedback(btnApply, { normal = GRAYBTN, hover = GRAYHOVER, down = GRAYDOWN })
	wireButtonFeedback(btnUndo, { normal = GRAYBTN, hover = GRAYHOVER, down = GRAYDOWN })

	-- =========================
	-- Preview
	-- =========================
	local previewLabel = label("Preview", 14, MUTED, true)
	previewLabel.LayoutOrder = 7
	previewLabel.Parent = content

	local previewFrame = Instance.new("ScrollingFrame")
	previewFrame.LayoutOrder = 8
	previewFrame.Parent = content
	previewFrame.Size = UDim2.new(1, 0, 0, 160)
	previewFrame.BackgroundColor3 = PANEL
	previewFrame.BorderSizePixel = 0
	addCorner(previewFrame, 12)
	addStroke(previewFrame, 1, OUTLINE, 0)
	previewFrame.ScrollBarThickness = 8
	previewFrame.ScrollingDirection = Enum.ScrollingDirection.Y
	previewFrame.Active = true
	previewFrame.AutomaticCanvasSize = Enum.AutomaticSize.None
	previewFrame.CanvasSize = UDim2.new(0, 0, 0, 0)

	previewFrame.MouseEnter:Connect(function()
		root.ScrollingEnabled = false
	end)
	previewFrame.MouseLeave:Connect(function()
		root.ScrollingEnabled = true
	end)

	local previewText = Instance.new("TextLabel")
	previewText.Parent = previewFrame
	previewText.BackgroundTransparency = 1
	previewText.TextXAlignment = Enum.TextXAlignment.Left
	previewText.TextYAlignment = Enum.TextYAlignment.Top
	previewText.Font = Enum.Font.Code
	previewText.TextSize = 12
	previewText.TextColor3 = TEXT
	previewText.TextWrapped = true
	previewText.AutomaticSize = Enum.AutomaticSize.Y
	previewText.Size = UDim2.new(1, -12, 0, 0)
	previewText.Position = UDim2.new(0, 6, 0, 6)
	previewText.Text = "Preview will appear here…"

	local function updatePreviewCanvas()
		previewFrame.CanvasSize = UDim2.new(0, 0, 0, previewText.AbsoluteSize.Y + 12)
	end
	previewText:GetPropertyChangedSignal("AbsoluteSize"):Connect(updatePreviewCanvas)
	previewText:GetPropertyChangedSignal("Text"):Connect(updatePreviewCanvas)
	updatePreviewCanvas()

	-- =========================
	-- Log
	-- =========================
	local logLabel = label("Log", 14, MUTED, true)
	logLabel.LayoutOrder = 9
	logLabel.Parent = content

	local logFrame = Instance.new("ScrollingFrame")
	logFrame.LayoutOrder = 10
	logFrame.Parent = content
	logFrame.Size = UDim2.new(1, 0, 0, 160)
	logFrame.BackgroundColor3 = PANEL
	logFrame.BorderSizePixel = 0
	addCorner(logFrame, 12)
	addStroke(logFrame, 1, OUTLINE, 0)
	logFrame.ScrollBarThickness = 8
	logFrame.ScrollingDirection = Enum.ScrollingDirection.Y
	logFrame.Active = true
	logFrame.AutomaticCanvasSize = Enum.AutomaticSize.None
	logFrame.CanvasSize = UDim2.new(0, 0, 0, 0)

	logFrame.MouseEnter:Connect(function()
		root.ScrollingEnabled = false
	end)
	logFrame.MouseLeave:Connect(function()
		root.ScrollingEnabled = true
	end)

	local logText = Instance.new("TextLabel")
	logText.Parent = logFrame
	logText.BackgroundTransparency = 1
	logText.TextXAlignment = Enum.TextXAlignment.Left
	logText.TextYAlignment = Enum.TextYAlignment.Top
	logText.Font = Enum.Font.Code
	logText.TextSize = 12
	logText.TextColor3 = TEXT
	logText.TextWrapped = true
	logText.AutomaticSize = Enum.AutomaticSize.Y
	logText.Size = UDim2.new(1, -12, 0, 0)
	logText.Position = UDim2.new(0, 6, 0, 6)
	logText.Text = ""

	local function updateLogCanvas()
		logFrame.CanvasSize = UDim2.new(0, 0, 0, logText.AbsoluteSize.Y + 12)
	end
	logText:GetPropertyChangedSignal("AbsoluteSize"):Connect(updateLogCanvas)
	logText:GetPropertyChangedSignal("Text"):Connect(updateLogCanvas)
	updateLogCanvas()

	-- =========================
	-- URL panel + copy
	-- =========================
	local urlBox = Instance.new("TextBox")
	urlBox.LayoutOrder = 11
	urlBox.Parent = content
	urlBox.Size = UDim2.new(1, 0, 0, 32)
	urlBox.BackgroundColor3 = PANEL
	urlBox.BorderSizePixel = 0
	addCorner(urlBox, 10)
	addStroke(urlBox, 1, OUTLINE, 0)
	urlBox.ClearTextOnFocus = false
	urlBox.Font = Enum.Font.Code
	urlBox.TextSize = 12
	urlBox.TextColor3 = TEXT
	urlBox.TextXAlignment = Enum.TextXAlignment.Left
	urlBox.Text = safeStr(settings.lastUrl)
	urlBox.PlaceholderText = "Dashboard URL (Copy URL button)"
	urlBox.TextEditable = false

	local urlRow = Instance.new("Frame")
	urlRow.LayoutOrder = 12
	urlRow.Parent = content
	urlRow.BackgroundTransparency = 1
	urlRow.Size = UDim2.new(1, 0, 0, 32)

	local urlGrid = Instance.new("UIGridLayout")
	urlGrid.Parent = urlRow
	urlGrid.FillDirection = Enum.FillDirection.Horizontal
	urlGrid.SortOrder = Enum.SortOrder.LayoutOrder
	urlGrid.CellPadding = UDim2.new(0, 10, 0, 0)
	urlGrid.CellSize = UDim2.new(0.5, -5, 1, 0)

	local btnSelectUrl = smallButton("Select URL", GRAYBTN, TEXT)
	btnSelectUrl.Parent = urlRow
	wireButtonFeedback(btnSelectUrl, { normal = GRAYBTN, hover = GRAYHOVER, down = GRAYDOWN })

	local btnCopyUrl = smallButton("Copy URL", GRAYBTN, TEXT)
	btnCopyUrl.Parent = urlRow
	wireButtonFeedback(btnCopyUrl, { normal = GRAYBTN, hover = GRAYHOVER, down = GRAYDOWN })

	-- =========================
	-- Show/hide helpers
	-- =========================
	local function setManualVisible(on)
		manualRow.Visible = on
		manualRow.Size = UDim2.new(1, 0, 0, on and 32 or 0)
	end

	local function setLogsVisible(on)
		logLabel.Visible = on
		logFrame.Visible = on
		logLabel.Size = UDim2.new(1, 0, 0, on and 22 or 0)
		logFrame.Size = UDim2.new(1, 0, 0, on and 160 or 0)
	end

	local function setAutoUI(isAuto)
		autoOn = (isAuto == true)
		if autoOn then
			btnAuto.Text = "Auto: ON"
			btnAuto.BackgroundColor3 = GREEN
			btnAuto.TextColor3 = Color3.fromRGB(10, 10, 10)
			setManualVisible(false)
		else
			btnAuto.Text = "Auto: OFF"
			btnAuto.BackgroundColor3 = GRAYBTN
			btnAuto.TextColor3 = TEXT
			setManualVisible(true)
		end
		settings.autoOn = autoOn
		writeSettings(plugin, settings)
	end

	local function setLogsUI(isOn)
		logsOn = (isOn == true)
		if logsOn then
			btnLogs.Text = "Logs: ON"
			btnLogs.BackgroundColor3 = GREEN
			btnLogs.TextColor3 = Color3.fromRGB(10, 10, 10)
			setLogsVisible(true)
		else
			btnLogs.Text = "Logs: OFF"
			btnLogs.BackgroundColor3 = GRAYBTN
			btnLogs.TextColor3 = TEXT
			setLogsVisible(false)
		end
		settings.logsOn = logsOn
		writeSettings(plugin, settings)
	end

	local function setStatus(text, color)
		statusBtn.Text = text
		if color then
			statusBtn.BackgroundColor3 = color
		end

		-- status dot mirrors status color (fallback gray)
		if color then
			dot.BackgroundColor3 = color
		else
			dot.BackgroundColor3 = GRAYBTN
		end
	end

	local function setRules(text)
		rules.Text = text
	end

	local function setPreview(text)
		previewText.Text = text or ""
	end

	local function setUrl(url)
		url = safeStr(url)
		urlBox.Text = url
		settings.lastUrl = url
		writeSettings(plugin, settings)
	end

	-- Toolbar open/close (persist)
	openBtn.Click:Connect(function()
		dock.Enabled = not dock.Enabled
		settings.dockEnabled = dock.Enabled
		writeSettings(plugin, settings)
	end)

	-- Toggle buttons (persist)
	btnAuto.MouseButton1Click:Connect(function()
		setAutoUI(not autoOn)
	end)

	btnLogs.MouseButton1Click:Connect(function()
		setLogsUI(not logsOn)
	end)

	-- Defaults from settings
	setAutoUI(autoOn)
	setLogsUI(logsOn)

	-- URL helpers
	btnSelectUrl.MouseButton1Click:Connect(function()
		urlBox:CaptureFocus()
		urlBox.CursorPosition = 1
		urlBox.SelectionStart = #urlBox.Text + 1
	end)

	btnCopyUrl.MouseButton1Click:Connect(function()
		local ok = pcall(function()
			if setclipboard then
				setclipboard(urlBox.Text)
			end
		end)

		if not ok then
			urlBox:CaptureFocus()
			urlBox.CursorPosition = 1
			urlBox.SelectionStart = #urlBox.Text + 1
		end
	end)

	-- Open dashboard button (best-effort)
	btnOpenDash.MouseButton1Click:Connect(function()
		local url = urlBox.Text
		-- Some Studio builds support plugin:OpenUrl(). Guard it.
		local opened = false
		if typeof(plugin.OpenUrl) == "function" then
			opened = pcall(function()
				plugin:OpenUrl(url)
			end)
		end
		if not opened then
			-- fallback: copy to clipboard if possible
			pcall(function()
				if setclipboard then
					setclipboard(url)
				end
			end)
		end
	end)

	-- Initial status styling
	setStatus("Status: Disconnected", GRAYBTN)
	setRules("Rules: unknown")

	return {
		dock = dock,

		-- buttons
		btnConnect = btnConnect,
		btnOpenDash = btnOpenDash,
		statusBtn = statusBtn,

		btnAuto = btnAuto,
		btnLogs = btnLogs,

		btnFetch = btnFetch,
		btnPreview = btnPreview,
		btnApply = btnApply,
		btnUndoHint = btnUndo,

		-- text / panels
		rules = rules,
		help = help,

		previewFrame = previewFrame,
		previewText = previewText,

		logFrame = logFrame,
		logText = logText,

		urlBox = urlBox,
		btnSelectUrl = btnSelectUrl,
		btnCopyUrl = btnCopyUrl,

		-- setters (Main uses these)
		setManualVisible = setManualVisible,
		setLogsVisible = setLogsVisible,
		setAutoUI = setAutoUI,
		setLogsUI = setLogsUI,
		setStatus = setStatus,
		setRules = setRules,
		setPreview = setPreview,
		setUrl = setUrl,

		-- status dot (optional for Main)
		statusDot = dot,

		-- theme (optional)
		theme = {
			BG = BG, PANEL = PANEL, OUTLINE = OUTLINE,
			TEXT = TEXT, MUTED = MUTED, GREEN = GREEN,
			GRAYBTN = GRAYBTN, RED = RED, YELLOW = YELLOW,
		},
	}
end

return Widget


==========================================================================================
FILE: game/ReplicatedStorage/PersponifyStudioAI/Validation/FastChecks
CLASS: ModuleScript
BYTES: 6483
SHA1: len=6483|a=39290|b=45745
------------------------------------------------------------------------------------------
-- Core/FastChecks.lua
-- Warnings-only. No side effects. No throws.
-- Upgraded: better action-shape checks, safer path extraction, optional caps from Config.

local FastChecks = {}

-- Optional Config (FastChecks should still work without it)
local hasConfig, Config = pcall(function()
	return require(script.Parent.Config)
end)
if not hasConfig then
	Config = nil
end

-- =========================
-- Helpers (schema-tolerant)
-- =========================
local function getActions(tx)
	if typeof(tx) ~= "table" then return nil end
	if typeof(tx.actions) == "table" then return tx.actions end
	if typeof(tx.plan) == "table" and typeof(tx.plan.actions) == "table" then
		return tx.plan.actions
	end
	return nil
end

local function warn(out, code, message, actionIndex, path)
	table.insert(out, {
		level = "WARN",
		code = tostring(code or "WARN"),
		message = tostring(message or ""),
		actionIndex = actionIndex,
		path = path,
	})
end

local function normalizePath(p)
	if typeof(p) ~= "string" then return nil end
	p = p:gsub("^%s+", ""):gsub("%s+$", "")
	if p == "" then return nil end
	p = p:gsub("\\", "/")
	p = p:gsub("%.", "/")
	p = p:gsub("/+", "/")
	p = p:gsub("^/", ""):gsub("/$", "")
	return p
end

local function getRoot(path)
	path = normalizePath(path)
	if not path then return nil end
	local first = string.split(path, "/")[1]
	if not first or first == "" then return nil end
	return string.lower(first)
end

local function lowerType(t)
	if typeof(t) ~= "string" then return "" end
	return string.lower(t)
end

local function isArray(t)
	return typeof(t) == "table" and (t[1] ~= nil or next(t) == nil)
end

local function bytesOfString(s)
	if typeof(s) ~= "string" then return 0 end
	return #s
end

local function getMaxSourceBytes()
	if Config and typeof(Config.MaxSourceBytes) == "number" then
		return Config.MaxSourceBytes
	end
	return 250000
end

local function getMaxActions()
	if Config and typeof(Config.MaxActionsPerTx) == "number" then
		return Config.MaxActionsPerTx
	end
	return 250
end

-- Extract the most relevant path for warnings depending on action type
local function extractPathForAction(a)
	if typeof(a) ~= "table" then return nil end

	local t = lowerType(a.type)

	-- createInstance / createFolder / etc
	if t == "createinstance" or t == "createfolder" or t == "createmodulescript" or t == "createscript" or t == "createlocalscript" then
		return a.parentPath or a.parent or a.parent_path
	end

	-- moveInstance
	if t == "moveinstance" or t == "move_instance" or t == "setparent" or t == "set_parent" then
		return a.path or a.target or a.targetPath or a.target_path
	end

	-- delete / rename / setProperty / setProperties / editScript / setAttribute(s)
	return a.path or a.target or a.targetPath or a.target_path or a.parentPath or a.parent
end

local function extractSecondPathForAction(a)
	if typeof(a) ~= "table" then return nil end
	local t = lowerType(a.type)
	if t == "moveinstance" or t == "move_instance" or t == "setparent" or t == "set_parent" then
		return a.newParentPath or a.parentPath or a.parent
	end
	return nil
end

-- =========================
-- FastChecks.run
-- =========================
function FastChecks.run(tx)
	local out = {}

	if typeof(tx) ~= "table" then
		warn(out, "TX_NOT_TABLE", "Transaction is not a table.")
		return out
	end

	-- Protocol mismatch warning (non-blocking)
	if Config and tx.protocolVersion ~= nil and tx.protocolVersion ~= Config.ProtocolVersion then
		warn(out, "PROTOCOL_MISMATCH", ("tx.protocolVersion=%s expected=%s"):format(tostring(tx.protocolVersion), tostring(Config.ProtocolVersion)))
	end

	local actions = getActions(tx)
	if not actions then
		warn(out, "NO_ACTIONS", "Transaction has no actions list.")
		return out
	end

	-- Too many actions warning (non-blocking)
	if isArray(actions) and #actions > getMaxActions() then
		warn(out, "TOO_MANY_ACTIONS", ("actions=%d max=%d"):format(#actions, getMaxActions()))
	end

	local allowedRoots = {
		workspace = true,
		replicatedstorage = true,
		serverscriptservice = true,
		serverstorage = true,
		startergui = true,
		starterplayer = true,
		starterpack = true,
		lighting = true,
		soundservice = true,
		teams = true,
		game = true,
	}

	for i, a in ipairs(actions) do
		if typeof(a) ~= "table" then
			warn(out, "ACTION_NOT_TABLE", "Action is not a table.", i)
			break
		end

		local rawType = a.type
		local t = tostring(rawType or "")
		if t == "" then
			warn(out, "MISSING_TYPE", "Action is missing type.", i)
		end

		local lt = lowerType(t)

		-- Path-related warnings (never blocking)
		local path = extractPathForAction(a)
		local root = getRoot(path)

		if path ~= nil and not root then
			warn(out, "BAD_PATH", "Path is malformed.", i, path)
		end

		if root and not allowedRoots[root] then
			warn(out, "UNCOMMON_ROOT", ("Path root '%s' is uncommon and may be incorrect."):format(root), i, path)
		end

		-- Secondary path check for moveInstance
		local path2 = extractSecondPathForAction(a)
		if path2 ~= nil and not getRoot(path2) then
			warn(out, "BAD_PARENT_PATH", "Destination parent path is malformed.", i, path2)
		end

		-- Source size sanity (create/edit) still non-blocking
		if lt == "editscript" or lt == "edit_script" or lt == "createscript" or lt == "createlocalscript" or lt == "createmodulescript" or lt == "createinstance" then
			if a.source ~= nil then
				if typeof(a.source) ~= "string" then
					warn(out, "SOURCE_NOT_STRING", "Action source must be a string when provided.", i, path)
				else
					local b = bytesOfString(a.source)
					local maxB = getMaxSourceBytes()
					if b > maxB then
						warn(out, "SOURCE_TOO_LARGE", ("source bytes=%d max=%d"):format(b, maxB), i, path)
					end
				end
			elseif lt == "editscript" or lt == "edit_script" then
				warn(out, "EDIT_NO_SOURCE", "editScript has no source string.", i, path)
			end
		end

		-- Table shape sanity (non-blocking)
		if lt == "setproperties" or lt == "set_properties" or lt == "batchsetproperties" then
			if typeof(a.properties) ~= "table" and typeof(a.props) ~= "table" and typeof(a.values) ~= "table" then
				warn(out, "SET_PROPERTIES_BAD", "setProperties missing properties table.", i, path)
			end
		end

		if lt == "setattributes" or lt == "set_attributes" then
			if typeof(a.attributes) ~= "table" and typeof(a.props) ~= "table" and typeof(a.values) ~= "table" then
				warn(out, "SET_ATTRIBUTES_BAD", "setAttributes missing attributes table.", i, path)
			end
		end
	end

	return out
end

return FastChecks


==========================================================================================
FILE: game/Workspace/AITest/HelloModule
CLASS: ModuleScript
BYTES: 62
SHA1: len=62|a=5673|b=53990
------------------------------------------------------------------------------------------
return function() print("hello from Persponify Studio AI") end
